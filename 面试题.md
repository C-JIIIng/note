### ==项目==

**能不能简要介绍一下你的项目？**

金融客户流失预警项目是我们大数据人工智能课程的一个课程设计大作业，该项目主要是为了预测未来一段时间内该app用户的流失可能性，从而能够为其提供针对性的服务和挽留策略。我们拿到的原始数据中有29个字段，主要包括用户的唯一标识，点击时间，点击类型，资金账号，省份，城市，设备类型，设备型号，设备分辨率等29个字段，我们需要对该原始数据进行清洗和数据质量检查，然后进行特征工程，抽取出feature表和label表，然后导入人工智能平台来进行预测。

我主要负责的是特征工程中的feture表和label表的提取工作，比较困难的部分是做特征联想，如何根据原有字段，衍生出一些新的有用的字段。经过头脑风暴，最后我们feature表中定下来的是 27 个特征，包括用户的唯一标识，是否是周末，过去一周工作日内不同时间段的点击次数，过去3天工作日内不同时间段内相邻两次点击时间差的均值，最大最小值等。

训练预测数据的提取逻辑是基于滑动时间窗方法。我们假定今天是运行时间，提取过去4个月时间作为feature的数据，提取未来一周作为label的数据，这个是作为模型训练的数据；之后做模型验证的数据则是在这基础上再往后推移一周。

sql 部分的逻辑是

+ 先将元数据导入hdfs中，然后在hive中创建文本表，将数据导入到表中
+ 将文本表中的数据导入到ORC表中，
+ 创建一个临时表，存入过去4周到未来一周的数据，主要是对时间做特殊处理，提取出年月日和时分秒，然后用case when 将时间进行分段，将其标记为0/1，方便后面的最终feature表的数据提取。

```sql
insert into tmp_table
select
	t1.tdid,
	t1.click_key,
	...
	case when (t1.account = 'unknown') then 0 else 1 end as has_account,
	case when date_format(t1.click_time,'u') >5 then 1 else 0 as is_weekend,
	case when hour(t1.click_time) in () then 1 else 0,
	case when t1.hhmmss bewteen 'xxxxx' and 'xxxxx' as flagxxxxxxxxx,
	....
from (
	select 
    	t.tdid,
    	nvl(t.click_type,'unknown') as click_type,
        from_unixtime(bigint(substring(click_time,1,10))) as click_time,
        from_unixtime(bigint(substring(click_time,1,10)), 'yyyyMMdd') as click_date,
        from_unixtime(bigint(substring(click_time,1,10)), 'HHmmss') as hhmmss,
    	...
    from t_ods_user_events AS t
    where from_unixtime(bigint(substring(click_time,1,10)), 'yyyyMMdd') between date_add('xxxxxx',-30) and date_add('xxxxxxx',7) 
) as t1
```

+ 根据临时表来进行feature 和 label 的提取

  + 这里要定义一张活跃用户的表，这张表主要记录的是过去一段时间内较为获取的用户

  ```sql
  insert into table train_feature_table
  select
  	a1.tdid
  	nvl(a2.cnt_linchen,0) as cnt_linchen,
  	
  from (
  	select tdid
      from train_tdid_active
  ) as a1
  
  left join (
  	select 
      	t2.tdid,
      	sum(t2.islinchen) as cnt_linchen
      from tmp_table as t2
      where t2.click_date between date_add() and date_add()
      group by t2.tdid
  ) as a2
  on a1.tdid = a2.tdid
  
  left join(
  	select
      	tdid,
      	avg(unix_timestamp(click_time) - unix_timestap(lagtime)) as avg_diff_1w
      from (
      	select
          	t2.tdid,
          	t2.click_time,
          	lag(t2.click_time) over(partition by t2.tdid order by t2.click_time) lagtime
          from tmp_table as t2
          where ...
      )
      group by tdid
  ) as a3
  on a1.tdid = a3.tdid
  ```



### ==计算机网络==

----

1. 计算机网络还记得吗，TCP/IP协议说一下吧，各层有什么协议，分别什么作用说一下

![image-20200318091521271](E:\研究生\面试\img\image-20200318091521271.png)

+ **网络接口层**，包含osi模型中的物理层和数据链路层
  + 物理层：是利用传输介质为数据链路层提供物理连接。
  + 数据链路层：是定义了电信号的分组方式，为网络层提供服务，解决两个相邻节点之间的通信问题，将不可靠的物理链路转换称为对网路层无差错的数据链路，传送的协议数据单元称为数据帧。
+ **网络层**
  + IP协议、ICMP协议、ARP协议、RARP协议、BOOTP协议
  + 为传输层服务，传送的协议数据单元称为数据包或分组，主要作用是解决如何使得数据包通过各节点传送的问题，即通过路径选择算法将数据包送往目的地。同时引入一套新的地址用来区别不同的子网，即网络地址。
  + 规定网路地址的协议称为ip协议，他定义的地址称为ip地址，比如ipv4，他规定网路地址由32位2进制表示
  + ip地址分为两段，网络地址和主机地址，用子网掩码来表示
  + arp协议：通过广播的方式发送数据包，获取目标主机的mac地址
  + icmp协议：网络控制报文协议，因为ip协议是不可靠的协议，不能保证数据被送达，当传送ip数据包发生错误时，ICMP协议就会把错误信息封包，然后传送给主机，一般用于检测网络是否通畅，比如ping
+ **传输层**
  + 为上层协议提供端口对端口的可靠和透明的数据传输服务
  + TCP协议
    + 传输控制协议，面向连接的协议，在传输数据前必须先建立连接，数据传送结束之后要释放连接，是可靠的
  + UDP协议
    + 面向无连接的不可靠的传输协议，但是在某些情况下是一种最有效的工作方式
+ **应用层**
  + HTTP、FTP、DNS等协议
  + DNS域名解析的过程
    + 用户主机上运行着DNS的客户端
    + 浏览器将接受到的url中抽取出**域名字段**，就是访问的主机名，并将这个主机名传送给dns应用的客户端
    + dns客户端向dns服务器发送一份查询报文，报文中包含着要访问的主机名字段
    + 客户机最终会收到一份回答报文，包含该主机名对应的ip地址
    + 那么浏览器就可以向该ip地址定位的http服务器发起tcp连接

---

**2. TCP 的三次握手和四次挥手**

**三次握手**

+ 第一次握手：建立连接时，客户端a发送syn包（syn=j）到服务器b，并进入syn_send状态，等待服务器b的确认
+ 第二次握手：服务器b收到syn包，必须确认客户a的syn（ack = j+1），同时发送自己的一个 syn包（syn = k），即syn+ack包，此时服务器b进入syn_received状态
+ 第三次握手：客户端a收到服务器b的syn+ack包，向服务器b发送确认包ack（ack=k+1），此包发送完毕，客户端a和服务器b就完成了三次握手

**四次挥手**

+ 客户端a发送一个fin（fin=j）包，用来关闭客户端a到服务器b的数据传送
+ 服务器b收到fin包，发送一个ack包（ack=j+1）
+ 服务器b关闭与客户端a的连接，向客户端a发送一个fin包（fin=k）
+ 客户端a收到之后，发送一个ack包（ack=k+1）

**TCP的重传机制**

---

**3. HTTP1.1和1.0区别**

http1.0中默认使用短连接，也即客户端和服务器端没进行一次http操作，就要建立一次连接，任务结束就中断连接，如果在访问过程中还要请求其他web资源，就会重新建立一个http会话

http1.1中，默认使用长连接，也即当打开网页之后，客户端和服务器端之间用于传输http数据的tcp连接就不会断开。但并不是永久连接，有时间限制。服务器有时会告诉客户端超时时间，timeout=20，如果没有告诉，则服务器端会主动发起四次挥手，断开连接。

---

**4. 输入URL访问网站的整体流程，越详细越好**

+ 浏览器会查看域名的ip地址
  + 使用了dns协议，向dns服务器请求ip地址
+ 浏览器向web服务器发送一个http请求
  + http请求的首部字段
    + accept：能够处理的**媒体类型**及媒体类型的相对优先级
    + Accept-Charset ：支持的**字符集**及字符集优先级顺序
    + Accept-Encoding：支持的**内容编码**及优先级
    + Accept-Language：能够处理的自然语言集及优先级
    + Authorization：用户代理的认证信息
    + Expect：写明所期望的扩展
    + From：告知服务器使用用户代理的用户的**电子邮件地址**
    + **Host：请求的资源所处的互联网主机名和端口号**
    + Range：资源的请求范围
  + tcp协议会将http请求报文分割为报文段，然后可靠的传输给对方
  + ip协议会搜索对方的地址，一边中转一边传送
  + tcp协议会从对方那接收到报文段，然后重组请求报文，
+ 服务器处理请求
+ 服务器发回一个html响应
  + 响应的过程和请求过程一样。
+ 浏览器开始显示html

---

**5. Http中200、302、304、404和500等响应状态码所表示的意义？**

200:   访问成功（表示一切正常，返回的是正常请求结果）
302：临时重定向（指出被请求的文档已被临时移动到别处，此文档的新的URL在Location响应头中给出）
304：未修改（表示客户机缓存的版本是最新的，客户机应该继续使用它。）
404：访问的文件不存在（服务器上不存在客户机所请求的资源）
500：内部服务器错误（服务器端的CGI、ASP、JSP等程序发生错误）



**get和post的区别**

+ get会将请求参数添加到url后面，安全性低，并且受到url长度的限制，一般是用来获取资源的；
+ post不会将参数跟在url后面，安全性高，参数长度不受url限制，一般是用来更新资源的

---

### ==MySql==

#### 1.事务隔离级别

##### 1. 什么是事务

事务就是逻辑上的一组操作，要么都执行，要么都不执行

##### 2. 事务的特性（ACID）

+ 原子性
+ 一致性
+ 隔离性
+ 持久性

##### 3. 并发事务带来的问题

+ 脏读
+ 丢失修改
+ 不可重复读
+ 幻读

##### 4. 事务隔离级别

+ 读取未提交：允许读取尚未提交的数据
+ 读取已提交：允许读取已经提交的数据
+ 可重复读：对同一个字段的读取结果是一样的，
+ 可串行化：所有事务逐个执行

#### 2. 索引

##### 1. 索引的本质是什么？

MySQL的基本存储结构是页，记录都存在页里面

+ 每个数据页可以组成一个双向链表
+ 每个数据页中的记录又可以组成一个单向链表
+ 每个数据页都会为存储在它里边儿的记录生成一个页目录

如果我们写select * from user where indexname = 'xxx'

**没有进行任何优化的sql语句**

+ 定位到记录所在的页:需要遍历双向链表，找到所在的页
+ 从所在的页内中查找相应的记录:由于不是根据主键查询，只能遍历所在页的单链表了
+ 在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O(n)

**使用索引之后**

+ 就是将无序的数据变得有序，底层结构就是B+树结构
+ 现在通过 “目录” 就可以很快地定位到对应的页上了（二分查找，时间复杂度近似为O(logn)）

##### 2. b+树索引方式

+ MyISAM
  + b树的非叶子节点存放着目录项记录
  + b树的叶子节点存放着数据记录的地址
  + 索引时，首先按照索引方法搜索索引，如果指定的key值存在，取出其data域的值
  + 然后根据data域的值去读取响应的数据
+ InnoDB
  + InnoDB中，表数据文件本身就是一个 B+Tree 组织的一个索引结构，也即**叶节点的data域保存了完整的数据记录**
  + InnoDB的所有**辅助索引都引用主键作为data域。**
  + 因此，我们推荐不要使用过长的字段作为主键，导致辅助索引变得过大
  + 同时，推荐使用单调的字段作为主键，会降低b+tree的分裂次数

##### 3. 什么时候索引会失效

+ 在where子句中**进行null值判断**的话会导致引擎放弃索引而产生全表扫描
+ 避免在where子句中使用`!= ,< >`这样的符号,否则会导致引擎放弃索引而产生全表扫描
+ 避免在where子句中使用`or`来连接条件,**因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描**
+ like的模糊查询以%开头，索引失效
+ 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引
+ 如果MySQL预计使用全表扫描要比使用索引快，则不使用索引
+ 不在索引列上做任何操作（计算，函数，（自动或者手动）类型装换），会导致索引失效而导致全表扫描

##### 4. 最左前缀

#### 3. sql优化



#### ==面试题==

+ **什么是索引，底层实现**

  + 索引是一种存储结构，可以帮助我们快速的进行数据查找，存储结构一般为hash索引或b+树索引，现在mysql的默认存储引擎innoDb使用的b+树索引，当查找某个等值的时候，一般使用hash索引会快一些，但是如果是范围查询，则还是需要使用到b+树索引。
  + myisam和innodb实现索引b+树索引的方式有些不同，myisam使用的是非聚簇索引，也即b+树叶子节点中只存有索引列，和整行数据的地址，innodb中是使用的聚簇索引，叶子节点中存储着key值和整行的数据。
  + 数据库主键一般都是使用自增id，能不能换成用户自定义不重复的key去作为主键呢，为什么(第一反应肯定是不行，我当时只回答了区分度，后来被引导到b+树上，后来明白了这是在问b+树叶子节点的知识，因为如果使用了自定义的key就无法保证叶子节点的顺序性了)  - 可以减少树的调整。

+ **b-树和b+树的区别**

  + b树，也即平衡多路查找树
    1. 根节点至少有两个子女
    2. 每个中间节点都包含k-1个元素和k个孩子，m/2 <= k <= m
    3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
    4. 所有叶子节点在同一层
    5. 每个节点中的元素从小到大排序，

  + b+树
    1. 有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
    2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且**叶子结点本身依关键字的大小自小而大顺序链接。**
    3. **所有的中间节点元素都同时存在于子节点**，在子节点元素中是最大（或最小）元素。
  + b+树的索引中，中间节点是纯粹的索引，不包含数据，所以b+树更为矮胖，
  + 同时b+叶子节点是顺序连接的，对于范围连接更为友好。

+ **什么样的列需要建立索引**

  + **经常搜索**的列
  + 经常需要根据**范围**进行搜索的列上创建索引
  + 经常需要**排序**的列上创建索引
  + 常使用在**WHERE**子句中的列上面创建索引，加快条件的判断速度。

+ **联合索引是什么？为什么需要注意联合索引中的顺序？**

  + 多个列组合成一个索引
  + 最左前缀索引

+ **什么时候索引会失效**

  + 使用不等号
  + 使用 != null
  + 模糊查询中 最左边是通配符
  + 当全表扫描比使用索引快
    + 在性别这个列上建立索引是否合适？
  + 索引列上做计算
  + 使用or条件连接

+ **什么是事务**

+ **ACID特性**

+ **同时多个事务运行有什么问题**

+ **MYSQL的隔离级别**

+ **mysql锁**

  + 共享锁和排他锁
  + 共享锁，也称为读锁，当用户要进行数据的读取时，对数据加上共享锁，会阻塞其他事务修改表数据。
  + 排它锁，也称为写锁，会阻塞其他事务读和写，

+ **锁和MVCC**

  + 数据库中常见的三种**并发控制机制**
    + 悲观并发控制 ---  锁
      + 共享锁 - 读锁
      + 排它锁 - 写锁
    + 乐观并发控制 - 乐观锁
      + 每次去拿数据的时候都认为别人不会修改，所以不会上锁
      + 但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据
      + 乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。
      + Java中的cas机制实现
    + 多版本并发控制 -MVCC
      + 在实际环境中，数据库的事务大多数都是读请求
      + 每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回
      + 在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。
      + mysql中的mvcc
        + 读操作，每个版本的数据行都具有一个唯一的时间戳，会从这里面拿去时间戳最大的那个返回
        + 写操作，会拿取最新版本的数据，然后操作，然后将版本号+1存入，表示一个新版本。

+ 三范式

+ 一条sql语句是怎么执行的

  + 连接器
  + 查询缓存
  + 分析器
  + 优化器
  + 执行器
  + 存储引擎

+ sql优化

  + 对查询进行优化，避免全表扫描，考虑在where和order by 涉及的列上建索引
  + 尽量避免在where子句中对null进行判断，会导致放弃索引全表扫描
  + 连续的数值，尽量使用between
  + 避免在 where 子句中对字段进行表达式操作
  + 避免在where子句中对字段进行函数操作
  + 不带任何条件的count会引起全表扫描





### ==Linux==

#### 面试题

+ 如何查看内存空间
  + 可以使用top指令
  + mem一行，提供了内存统计信息

+ 怎么利用top指令查看系统的负载情况
  + top指令输出的第一行
  + top 包含当前系统时间，系统运行的时间，系统在之前1,5,15min内cpu的平均负载值
+ linux怎么查看磁盘空间
  + 使用df指令
  + df -hl 查看磁盘剩余空间
  + df -h 查看每个根路径的分区大小

+ 如何查看进程

  + ps -ef  查看进程
    + 用户id
    + 进程id
    + 父进程id
    + 占cpu比例
    + 进程启动到现在的时间等

+ 写脚本杀死指定名称的进程

  + pgrep ${id} - 查看某进程的id

  ```java
  pgrep xxx | xargs kill -s 9
  $kill -s 9 `pgrep xxx`
  ```

+ 一个文件"ip.txt"，有两个字段ip(第一列)和访问时间(第二列)，找出访问次数最多的ip；

  ```shell
  awk '{ips[$1]++;} END {for(ip in ips) printf("%d%s\n",ip,ip[ips])}' ip.txt | sort -rnk 2 | head -n 1
  ```

+ 词频统计

  ```shell
  awk '{for(i=1;i<NF;i++){count[&i]++}} END {for(k in count){print k" "count[k]}}' words.txt | sort -rnk 2
  ```

### ==Java==

#### ==基础==

**Java8的特性** --- 看

+ 在接口中允许定义默认方法和静态方法
+ Java8最大的变化是引入**了函数式思想**，**也就是说函数可以作为另一个函数的参数**
  + 函数式接口，要求接口中**有且仅有一个抽象方法**，因此经常使用的Runnable，Callable接口就是典型的函数式接口。
  + lambda表达式
    + 用来表示这种只有一个抽象方法的函数式接口

+ **重载和重写的区别**
+ **String 和 StringBuffer 和 StringBuilder 的区别是什么？String为什么是不可变的？**
+ **== 和 equals**
+ **final**
+ **static 关键字**
+  **Java 中的异常处理**
+ **接口和抽象类的区别是什么**

#### ==JVM==

**软引用和弱引用的区别，用法**

+ softReference 类
  + 只有当内存不够时，才会被回收
  + 软引用可用来实现内存敏感的高速缓存。
  + 我们只需要将对象置为软引用，那么使用get方法时，如果返回null，则说明该对象已经被回收，如果不为null，则说明内存空间还较为充足
  + 由于垃圾回收会优先回收长时间闲置不用的软引用对象，所以软引用可以和一个引用队列联合使用，软引用所引用对象被垃圾回收，jvm就会将软引用加入到与之关联的引用队列中，可以用队列的poll方法，来查看引用对象是否已经被回收。
+ weakReference 类
  + 只具有**弱引用**的对象拥有**更短暂**的**生命周期**
  + 一旦发现了只具有**弱引用**的对象，不管当前**内存空间足够与否**，都会**回收**它的内存。
+ 区别
  + 个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。
  +  还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。



**仔细说一下你了了解的G1收集器器**

G1收集器的最大特点

+ 引入了分区的思路，弱化了分代的概念
+ 合理利用垃圾收集各个周期的资源，解决了其他收集器的很多缺陷

相比于CMS的改进

+ 使用标记-整理算法，不会产生空间碎片
+ 可以通过设置预期停顿时间（pause time） 来控制垃圾收集时间来避免雪崩现象
+ 实行并行和并发

在 G1 之前，JVM内存模型：

![image-20200320092039728](E:\研究生\面试\img\image-20200320092039728.png)

G1收集器的内存模型

![image-20200320092059958](E:\研究生\面试\img\image-20200320092059958.png)

**G1堆内存结构**

+ 队内存会切分为很多个固定大小区域
+ 堆内存中一个区域(Region)的大小可以通过**-XX:G1HeapRegionSize**参数指定，大小区间最小1M、最大32M，总之是2的幂次方。
+ 默认把堆内存按照2048份均分。

**G1堆内存分配**

+ E S O H

**G1回收流程**

![image-20200320092903705](E:\研究生\面试\img\image-20200320092903705.png)

+ 初始标记
  + 这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。
+ 并发标记
  + 从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记(Final Marking )阶段
+ 最终标记
  + 标记那些在并发标记阶段发生变化的对象，将被回收。
+ 筛选回收
  + 首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region。
  + 最后，G1中提供了**两种模式垃圾回收模式**，Young GC和Mixed GC，两种都是Stop The World(STW)的。

G1 的 

GC 模式

+ **YoungGC年轻代收集**
  + 在分配一般对象（非巨型对象）时，当所有eden region使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC。
  + 每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。
+ **mixed gc**
  + 当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc
  + 该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region
  + 这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。
+ G1没有fullGC概念，需要fullGC时，调用serialOldGC进行全堆扫描（包括eden、survivor、o、perm）。



**Java创建一个对象有几种方式**

+ 使用 new 方法

  + 检查类是否被加载
  + 为对象分配内存
  + 为分配的内存空间初始化零值
  + 对对象进行其他配置
  + 执行init方法

+ 使用反射手段

  + 使用class类的newInstance方法

    ```java
    User user = User.class.newInstance();
    ```

  + 使用Constructor类的newInstance方法

    ```java
    Constructor<User> constructor = 
    User.class.getConstructor();
    User user = constructor.newInstance();
    ```

+ 调用 clone 方法

  + 调用一个对象的clone 方法，要实现cloneable接口

+ 运用反序列化手段

  + 要对一个对象进行序列化，则该对象的类就必须实现serialization接口
  + 通过objectOutputStream 将java 对象的基本数据类型写入（ObjectWrite）OutputStream，然后使用使用ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。



##### 面试题

+ **什么情况下会发生栈内存溢出**
+ **运行时数据区**
+ **新生代，老年代，eden，survivor**
+ **完整的gc流程**

+ **垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。**
+ **JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。**
  + 可见性
    + 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中
    + 读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据
  + 有序性
    + 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
    + 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前
+ **简单说说你了解的类加载器，可以打破双亲委派么，怎么打破**
  + 我们编写的.java文件会由编译器转换为.class文件，中间保存着Java代码经过转换之后的虚拟机指令，当需要某个类的时候，就把这个文件加载到内存并创建对应的class对象
  + 类加载过程分为 **加载，验证，准备，解析，初始化**
  + 类加载器的任务是根据一个类的全限定名来读取这个类的二进制字节流到jvm中，然后转换成class对象
  + **启动类加载器，扩展类加载器，系统类加载器**
  + 启动类加载器主要加载的是JVM自身需要的类，由C++语言实现，负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中
  + 扩展（Extension）类加载器负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
  + 系统（System）类加载器负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。
  + **双亲委派模式**
  + **双亲委派模式的作用是**
    + 避免重复加载
    + 考虑安全因素
  + 打破双亲委派模式
    + 自己定义一个类加载器
    + 重写loadClass和findClass方法
+ **强引用、软引用、弱引用、虚引用的区别？**
+ **Java创建一个对象有几种方式**
+ JVM参数调优经验



#### ==并发编程==

**HashMap、HashTable、ConcurrentHashMap**

1. HashMap

+ 1.7 版本和1.8 版本之间比较的说明
+ 存储结构
+ 头插法（死链） 尾插法
+ 扩容
+ 计算桶位的方法
+ 扩容时重新计算位置的方法
+ 多线程访问不安全
+ 红黑树

2.HashTable

3.ConcurrentHashMap

> 利用 **CAS 和 synchronized** 来保证并发更新的安全
>
> 底层使用了 **数组+ 链表+ 红黑树** 来实现

+ **重要成员**

  + table：初始化发生在第一次插入操作，默认大小为16的数组
  + nextTable：扩容时新生成的数组，其大小为原数组的两倍。
  + sizeCtl ：默认为0，用来控制table的初始化和扩容操作
    + **-1** 代表table正在初始化
    + **-N** 表示有N-1个线程正在进行扩容操作
    + 如果table未初始化，表示table需要初始化的大小。
    + 如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n >>> 2)）。
  + Node：保存key，value及key的hash值的数据结构。
    + 其中value和next都用volatile修饰，保证并发的可见性。
  + ForwardingNode
    + 一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。
    + 只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动

+ **初始实例化**（懒惰初始化 - 1.8优化）

  + 只有在第一次put操作时，才会进行初始化

  + 使用cas来替换sizeCtl值，一开始会判断该值是否小于0，如果是，则说明已经有线程进行初始化，则放弃初始化
  + 初始化数组长度为16

+ **put 操作**

  + 假设初始化已经完成，put操作采用 cas+synchronized实行并发插入或更新操作
    + 如果该位置为空，则使用 cas 操作，将Node 放入对应的 bucket中
    + 如果出现冲突，则采用 synchronized 关键字
    + 如果当前 map 正在扩容，则和其他线程一起扩容

+ **table 扩容**

  + 什么时候会扩容呢？
    + 新增节点后，如果当前位置所在的链表大于8，但是，table的长度小于64，则会进行扩容，并触发transfer 来重新调整节点位置
    + 新增节点后，addcount统计tab中的节点个数大于阈值（sizeCtl），会触发 transfer，重新调整节点位置

+ **get方法**

  + 不需要加锁
  + 空表，返回null
  + 计算hash值，找到bucket 位置，为node节点直接返回，否则返回null

  ```java
  public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
      int h = spread(key.hashCode());
      if ((tab = table) != null && (n = tab.length) > 0 &&
          (e = tabAt(tab, (n - 1) & h)) != null) {
          if ((eh = e.hash) == h) {
              if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                  return e.val;
          }
          else if (eh < 0)
              return (p = e.find(h, key)) != null ? p.val : null;
          while ((e = e.next) != null) {
              if (e.hash == h &&
                  ((ek = e.key) == key || (ek != null && key.equals(ek))))
                  return e.val;
          }
      }
      return null;
  }
  ```

  



**原子性（synchronized、ReentrantLock（AQS））、可见性、有序性（volatile）**

**线程池**



##### 面试题

+ **详细说一下HashMap**
+ **HashMap扩容之后是要全部重新计算元素的下标吗**

+ **哈希冲突怎么解决，我说的链地址法，顺便便提了了ConcurrentHashMap中的红黑树**
+ **那么说一下HashTable和并发包里的ConcurrentHashMap之间的区别吧**
+ **说到红黑树，那你讲一下红黑树的性质，和它都怎么使用**





+ **说到了Java多线程，那你说一下多线程我们编程的时候都怎么用**
+ **并发和并行的区别，Java中如何做到线程间并发（我理理解这就是说如何实现线程间协作）**
+ **你平时有看源码的习惯吗，大概看了了哪些源码**





**说一下你理解的线程安全**

**说一下Java怎么保证线程安全**





**并发包源码有了解过么，把你知道的讲一讲**

**你刚才提到了了volatile关键字，那么这个关键字的作用你可以详细介绍一下吗**

**锁主要是用来解决什么问题的**

**锁保证了了可见性吗**

**为什么乐观锁策略会比悲观锁策略的效率要高**

**并发包里的容器器有了解过么，可以说一下你了了解的**

**线程池有使用过吗，你的项目要加入线程池的话你会怎么用**

+ **java.util.concurrent包里的锁介绍一下**

+ ArraryBlockingQueue的实现



### ==Hadoop==

#### 1. Zookeeper

+ **zookeeper节点类型**
+ **zookeeper实现原理**，**Zookeeper首领选取**
  + zab
    + 恢复模式 - leader选举 myid/zxid
    + 同步流程
+ **Zookeeper怎么保证原子性，也即一致性**
+ **zookeeper怎么实现分布式锁**
  + 控制时序
  + getChildren -- 获取path
  + exist -- 获取前一个节点的个数
+ **Zookeeper脑裂问题**
+ **zookeeper的watcher机制**
+ 二阶段提交算法
+ paxos算法

#### 2. Hadoop

+ **简要介绍一下hadoop**
  + 是一个分布式系统的基础框架，包括HDFS，MapReduce，YARN
  + HDFS是以分布式进行存储的文件系统，主要负责集群数据的存储和读取，是一个Master/Slave体系结构的分布式文件系统。

+ **安装配置hadoop的过程**
  + 安装jdk
  + 关闭防火墙
  + 配置hosts文件，方便hadoop通过主机名访问
  + 设置ssh免密码登录
  + 解压hadoop安装包，并配置环境变量
  + 修改配置文件
  + 格式化hdfs文件系统（*hadoop namenode -format*）
  + 启动hdfs（*$HADOOP_HOME/bin/start-all.sh*）
  + 使用jps来查看进程
  + scp
+ **hadoop急群众都分别需要启动哪些进程，分别是什么作用**
  + ActiveNamenode
  + StandbyNamenode
  + DateNode
  + ResourceManager
  + NodeManager
  + AplicationMaster
  + JournalNode
+ **hadoop中查杀作业和任务的指令**
  + hadoop job -list
  + hadoop job -kill job_id
  + yarn application -list
  + yarn application -kill application _id

#### 3. HDFS

+ **Hdfs读写流程，数据checkpoint流程**

+ **hdfs的容错机制**（block副本）

+ **hdfs的高可用性**（HA模式）

+ **zookeeper实现HDFS Active节点选举**

  ![image-20200325172141685](D:\Desktop\img\image-20200325172141685.png)

  + FailoverController 守护进程
  + monitor health 后台线程来识别nn的状态
  + faliovercontroller还和zk保持心跳连接
  + 机制就是 选举机制 节点类型 wathcer机制

+ **hdfs的安全模式**

+ **hdfs常见的配置文件有哪些？**
  
  + hdfs-site.xml
    + namenode存放fsimage的目录
    + namenode存放edits的目录
    + datanode存放block本地目录
    + 副本个数
    + block块大小



+ **yarn的工作机制** / 说说你对yarn 的理解
+ **请列出你所知道的hadoop资源调度器，并简要说明其工作方法**
+ **yarn的配置文件**
  + yarn-site.xml

#### 4. MapReduce

+ **mapreduce 流程，suffle过程**
+ **mapreduce中的combiner 和partition的区别**
  + partition 就是在本地buffer中对数据进行分区 且区内可以是排序的
  + buffer的存在是为了减少写入磁盘的I/O操作。
  + combiner 就是当mapper溢写出的文件有多个时，将其按照分区内部key排序的方式进行合并，使得，reduce端只需要抓取一次就能抓取到完整的。也可以节约带宽。
+ **描述mapreduce的过程，中间有几次写磁盘**

#### 5. hive

+ **为什么在大数据领域中要使用hive而不用mysql**，**hive优点**
  + Hive是一个基于Hadoop的数据仓库平台，通过hive，我们可以方便地进行ETL的工作。将用户编写的QL转化为相应的Mapreduce程序基于Hadoop执行。
  + 适合于离线批量处理
+ **Hive的体系结构**
  + **解释器、编译器、优化器、执行器**
  + **元数据**
+  **hive 保存元数据有哪些方式，各有哪些特点**
  + derby 
  + mysql 	
+ **hive内表外表的区别**
  + 在创建表的时候
    + 内表直接创建，create table
    + 外表有一个external 关键字
  + 在导入数据到外部表，数据并没有移动到自己的数据仓库目录下，也就是说外部表中的数据并不是由它自己来管理的，而内表则不一样； 
  + 在删除内表的时候，Hive将会把属于表的元数据和数据全部删掉；而删除外部表的时候，Hive仅仅删除外部表的元数据，数据是不会删除的！
+ **hive 存储形式，ORC、Parquet等列式存储的优点**
  + 文本文件
    + 行存储
    + 默认格式，数据不做压缩，
  + ==ORC表==
    + ORC表的出现时为了降低Hadoop数据存储空间和加速Hive查询速度
    + 是列式存储，压缩比较高
    + 文件是可切分的（split），不仅节省HDFS存储的资源，查询任务的输入数量减少，使用的MapTask也减少了。
    + 提供了多种索引，row group index， bloom filter index，







+ 分区，静态分区和动态分区
  + 
+ **简述Hive 桶表什么，什么作用，举例**
  +  分桶，就是将
  +  提高join的效率



+ **简述MapReduce实现join的几种方法**
  + **reduce side join**
    + 在map阶段同时读取两个文件，然后分别在每条上打上**标志，**
    + 在reduce阶段，将key相同的分到一个reduce中，然后根据tag来做笛卡尔乘积
  + **map side join**
    + 适合于一个**大表一个小表**的情况
    + 直接将小表存在map task内存中，然后只扫描大表，找出有key相同的值，有的话就输出
  + **semijoin**
    + 希望解决在reduce阶段跨机器的传输数据非常大，希望可以在**map阶段就能过滤掉一些不会参与join操作的数据。**
    + 选取一个小表，f1，将其中参与join的key抽取出来，存为f3，然后将f3复制到各个map中，然后将f2中不在f3中的记录过滤掉
    + 然后进行reduce side join 过程

+ **MapReduce实现基本SQL操作的原理**
  + join
    + 见上
  + group
    + 将GroupBy的字段组合为map的输出key值，利用MapReduce的排序，在reduce阶段保存LastKey区分不同的key。
  + distinct

+ **sql转化为MapReduce的过程**
  + Antlr定义SQL的语法规则，完成**SQL词法，语法解析**，将SQL转化为抽象语法树**AST Tree**
  + 遍历AST Tree，抽象出查询的基本组成单元**QueryBlock**
  + 遍历QueryBlock，翻译为执行操作树**OperatorTree**
  + **逻辑层优化器**进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量
  + 遍历OperatorTree，翻译为**MapReduce任务**
    + **物理层优化器**进行MapReduce任务的变换，生成最终的执行计划  

+ **什么是数据倾斜，怎么解决**
  + 数据分布不均匀，造成数据大量集中到一点
  + 在执行任务的时候，任务进度长时间维持在99%左右，查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。
  + groupby count(distinct) join
+ **hive优化**
  + 列剪裁和分区剪裁
    + 列剪裁就是在查询是指读取需要的列
    + 分区剪裁就是只读取需要的分区







+ 自定义函数

+ hive的用户自定义函数实现步骤与流程？

+ 三种自定义函数是什么？

+ 四种排序区别

  



### ==数据结构==

+ 红黑树
+ b+树和b-树的区别



1.自我介绍，讲了大概有5分钟左右 

2.Linux怎么查看系统进程的使用情况(本人接触过一点linux，就说了top指令，还说了一下top指令里面相关的参数) 

  3.怎么利用top指令查看系统的负载情况(我一直回答的是内存，面试官一直提醒我是负载，难道内存不算是负载嘛，黑人问号脸) 

  4.进程和线程的区别(进程：系统进行资源调度和分配的基本单位，进程间独享内存，一个系统至少一个进程；线程：cpu进行资源调度和分配的基本单位，线程间共享进程的内存，一个进程至少一个线程) 

  5.死锁产生的条件(1.互斥性；2.占有并等待；3.非抢占；4.循环等待) 

  6.能不能用java代码模拟一下线程死锁的情况(简单) 

 

  10.线程的几种状态(创建，运行，等待，阻塞，循环等待，终止，其中运行又分为了就绪和运行中) 

  11.能不能结合之前写的死锁代码具体讲一讲线程状态是怎么变化的 

  12.wait和sleep的区别(wait是object类的，它会释放锁，它只能被notify()或者notifyAll()唤醒；sleep是thread类的，它不会释放锁，sleep时间到了会自动恢复，之后面试官还在问还有吗，又是问号脸，真的想反问一句，还有吗？) 

  13.synchonized的底层实现(说了一下monitor指令) 

  手撕代码 

  1.反转链表(简单) 

  2.找出数组中连续子序列之和最大的子序列数组，并输出起止位置索引(第一反应贪心，但是想了一会可能是哪里想错了，一直卡在那里，面试官就问我想的怎么样了，我当时就想着先写出以一个来，就直接说想好了，正准备写的时候面试官让我直讲将思路，我就直接说暴力法，之后又问还有更好的方法嘛，我就说暂时没想到了，之后就结束了) 

  整个过程持续了一个多小时，感觉不错，面试官人挺好的，期间她女儿还跑来找她，女儿真的好可爱，许愿有二面





### ==算法题==

#### 1. 数组

##### 1. 最大连续子数组和

```java
// 1. 连续子数组的最大和
public static int maxSubArray(int[] nums) {
    int curMaxSum = 0;
    int maxSum = nums[0];
    for (int num : nums) {
        curMaxSum = Math.max(num, num + curMaxSum);
        maxSum = Math.max(curMaxSum, maxSum);
    }
    return maxSum;
}
// 如果同时要求输出子段的开始和结束列?
public static int[] maxSubArray2(int[] nums) {
    int curMaxSum = 0;
    int maxSum = nums[0];
    int startIndex = 0;
    int endIndex = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > nums[i] + curMaxSum) {
            startIndex = i;
            curMaxSum = nums[i];
        } else {
            curMaxSum = nums[i] + curMaxSum;
        }
        if (curMaxSum > maxSum) {
            endIndex = i;
            maxSum = curMaxSum;
        } else {
            maxSum = maxSum;
        }
    }
    return new int[] {maxSum, startIndex, endIndex};
}
```

##### 2. 最大子矩阵和

##### 3.乘积最大子序列

```java
public int maxProduct(int[] nums) {
    int max = Integer.MIN_VALUE, imax = 1, imin = 1;
    for (int num : nums) {
        //如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。
        if (num < 0) {
            int tmp = imax;
            imax = imin;
            imin = tmp;
        }
        imax = Math.max(num, imax * num);
        imin = Math.min(num, imin * num);

        max = Math.max(max, imax);
    }
    return max;
}
```

##### 4. 寻找最小的k个数(TopK问题)

+ 解法1，使用**快速排序**，然后将数排序O(nlogn) + O(k) = O(nlogn)
+ 解法2，使用**堆**来维护，怎么实现一个简单的优先队列

```java
// 使用快速排序思想
public int[] getLeastNumbers(int[] arr, int k) {
    if (k <= 0) return new int[0];
    if (k >= arr.length) return arr;
    partitionArray(arr, 0, arr.length-1, k);
    int [] res = new int[k];
    for (int i =0; i < k; i++) {
        res[i] = arr[i];
    }
    return res;
}

private void partitionArray(int[] arr, int low, int high, int k) {
    int m = partition(arr, low, high);
    if (m == k) {
        return;
    } else if (k < m) {
        partitionArray(arr, low, m - 1, k);
    } else {
        partitionArray(arr, m + 1, high, k);
    }
}

private int partition(int[] arr, int low, int high) {
    int i = low;
    int j = high;
    int p = arr[low];
    while (i < j) {
        while (i < j && arr[j] >= p) j--;
        arr[i] = arr[j];
        while (i < j && arr[i] < p) i++;
        arr[j] = arr[i];
    }
    arr[i] = p;
    return i;
}
```

```java
// 使用堆排序
public int[] getLeastNumbers(int[] arr, int k) {
    if (k <= 0) return new int[0];
    // 创建一个k大小的大根堆
    Queue<Integer> heap = new PriorityQueue<>((o1,o2) -> Integer.compare(o2,o1));
    for (int val : arr) {
        if (heap.size() < k || val < heap.peek())
            heap.offer(val);
        if (heap.size() > k)
            heap.poll();
    }
    int [] res = new int[k];
    int i = 0;
    for (int val : heap) {
        res[i++] = val;
    }
    return res;
}
```

```java
class Heap {
    public void heapSort(int[] arr) {
        buildHeap(arr);
        for(int i = arr.length - 1; i >= 1; i--) {
            swap(arr, 0, i);
            // 调整堆到最大堆
            heapify(arr, 0, i);
        }
    }

    private void buildHeap(int[] arr) {
        for (int i = (arr.length - 1) / 2; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
    }

    private void heapify(int[] arr, int index, int heapSize) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        int imax = index;
        if (left < heapSize && arr[left] > arr[imax]) imax = left;
        if (right < heapSize && arr[right] > arr[imax]) imax = right;
        if (imax != index) {
            swap(arr, imax, index);
            heapify(arr, imax, heapSize);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

##### 5. 寻找和为定值的两个数

```java
public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
    ArrayList<Integer> res = new ArrayList<>();
    if (array == null  || array.length < 2) return res;
    int i = 0;
    int j = array.length - 1;
    while (i < j) {
        if (array[i] + array[j] == sum) {
            res.add(array[i]);
            res.add(array[j]);
            return res;
        } else if (array[i] + array[j] < sum)
            i++;
        else
            j--;
    }
    return res;
}
```

##### 6. 寻找何为定值的多个数

##### 7.调整数组顺序使奇数位于偶数前面

```java
public void reOrderArray(int [] array) {
    int oddCount = 0;
    for (int num : array){
        if (num % 2 != 0)
            oddCount++;
    }
    int[] arr = array.clone();
    int i = 0, j = oddCount;
    for (int num : arr) {
        if(num % 2 == 0)
            array[j++] = num;
        else
            array[i++] =num;
    }
}
```



#### 2. 链表

##### 1. 从尾到头打印链表

```java

```



##### 2. 链表中倒数第k个结点

```java
public ListNode FindKthToTail(ListNode head,int k) {
    if (head == null || k <= 0) return null;
    ListNode p1 = head;
    while (p1 != null && k-- > 0) {
        p1 = p1.next;
    }
    if (k > 0) return null;
    ListNode p2 = head;
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    return p2;
}
```

##### 3. 反转链表

```java
public ListNode ReverseList(ListNode head) {
    ListNode preNode = null;
    ListNode curNode = head;
    while (curNode != null) {
        ListNode nextNode = curNode.next;
        curNode.next = preNode;
        preNode = curNode;
        curNode = nextNode;
    }
    return preNode;
}
```

##### 4. 合并两个排序的链表

```java
public ListNode Merge(ListNode list1,ListNode list2) {
    if (list1 == null) return list2;
    if (list2 == null) return list1;
    ListNode head = new ListNode(0);
    if (list1.val < list2.val) {
        head.next = list1;
        list1.next = Merge(list1.next, list2);
    } else {
        head.next = list2;
        list2.next = Merge(list1, list2.next);
    }
    return head.next;
}
```

##### 5. 复杂链表的复制

##### 6. 两个链表的第一个公共结点

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode commonNode;
    int len1 = getLength(pHead1);
    int len2 = getLength(pHead2);
    int s = Math.abs(len1 - len2);
    ListNode longNode = pHead1;
    ListNode shortNode = pHead2;
    if (len2 > len1) {
        longNode = pHead2;
        shortNode = pHead1;
    }
    for (int i = 0; i < s; i++) {
        longNode = longNode.next;
    }

    while (longNode != null && shortNode != null && longNode != shortNode) {
        longNode = longNode.next;
        shortNode = shortNode.next;
    }
    commonNode = longNode;
    return commonNode;

}
private int getLength(ListNode head) {
    int len = 0;
    while (head != null) {
        head = head.next;
        len++;
    }
    return len;
}
```

##### 7. 链表中环的入口结点

```java
public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) return null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) break;
    }
    if (fast.next == null || fast.next.next == null) return null;
    slow = head;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```

##### 8. 删除链表中重复的结点

+ 删除重复节点
+ 不删除重复节点

```java
public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null || pHead.next == null) return pHead;
    ListNode head = new ListNode(0);
    head.next = pHead;
    ListNode pre = head;
    ListNode cur = pHead;
    while (cur != null) {
        if (cur.next != null && cur.val == cur.next.val) {
            while (cur.next != null && cur.val == cur.next.val)
                cur = cur.next;
            // 这一步用来判断是否删除掉这个重复的元素，若删除，则pre.next = cur.next，否则 pre.next = cur
            pre.next = cur.next;
            cur = cur.next;
        } else {
            pre = pre.next;
            cur = cur.next;
        }
    }
    return head.next;
}
```



#### 3. 堆的使用

##### 1. topk系列问题

```java
public int[] getLeastNumbers(int[] arr, int k) {
    if (k <= 0) return new int[0];
    // 创建一个k大小的大根堆
    Queue<Integer> heap = new PriorityQueue<>((o1,o2) -> Integer.compare(o2,o1));
    for (int val : arr) {
        if (heap.size() < k || val < heap.peek())
            heap.offer(val);
        if (heap.size() > k)
            heap.poll();
    }
    int [] res = new int[k];
    int i = 0;
    for (int val : heap) {
        res[i++] = val;
    }
    return res;
}
```

```java
public int[] getLeastNumbers2(int[] arr, int k) {
    if (k <= 0) return new int[0];
    if (k >= arr.length) return arr;
    partitionArray(arr, 0, arr.length-1, k);
    int [] res = new int[k];
    for (int i =0; i < k; i++) {
        res[i] = arr[i];
    }
    return res;
}

private void partitionArray(int[] arr, int low, int high, int k) {
    int m = partition(arr, low, high);
    if (m == k) {
        return;
    } else if (k < m) {
        partitionArray(arr, low, m - 1, k);
    } else {
        partitionArray(arr, m + 1, high, k);
    }
}

private int partition(int[] arr, int low, int high) {
    int i = low;
    int j = high;
    int p = arr[low];
    while (i < j) {
        while (i < j && arr[j] >= p) j--;
        arr[i] = arr[j];
        while (i < j && arr[i] < p) i++;
        arr[j] = arr[i];
    }
    arr[i] = p;
    return i;
}
```

##### 2. 数据流的中位数

##### 3. 堆排序



#### 4. 各类排序算法

##### 1. 冒泡排序 

+ O(n^2)  
+ 稳定 
+ 最好 O(n) 
+ 最差 O(n^2)

```java
public void bubble_sort(int[] arr) {
    if (arr.length <= 1) return;
    for (int i = 0; i < arr.length; i++) {
        boolean flag = false;
        for (int j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = true;
            }
        }
        if (!flag) break;
    }
}
```

##### 2. 插入排序  

+ O(n^2)  
+ 稳定 
+ 最好 O(n) 
+ 最差 O(n^2)

```java
public void insertSort(int[] arr) {
    if (arr.length <= 1) return;
    for (int i = 1; i < arr.length; i++) {
        int j = i - 1;
        int value = arr[i];
        for (; j >= 0; j--) {
            if (arr[j] > arr[i]) {
                arr[j + 1] = arr[j];
            } else {
                break;
            }
        }
        arr[j + 1] = value;
    }
}
```

##### 3. 归并排序

+ 平均时间复杂度O(nlogn)
+ 时间复杂度 O(n)

```java
public void merge_sort(int [] nums) {
    merge_sort(nums, 0, nums.length - 1);
}

private void merge_sort(int[] nums, int low, int high) {
    if (low >= high) return;
    int mid = low + (high - low) / 2;
    merge_sort(nums, low, mid);
    merge_sort(nums, mid + 1, high);
    merge(nums, low, mid, high);
}

private void merge(int[] nums, int low, int mid, int high) {
    int [] tmp = new int[high - low + 1];
    int i = low;
    int j = mid + 1;
    int k = 0;
    while (i <= mid && j <= high) {
        if (nums[i] <= nums[j]){
            tmp[k++] = nums[i++];
        } else {
            tmp[k++] = nums[j++];
        }
    }
    while (i <= mid){
        tmp[k++] = nums[i++];
    }
    while (j <= high){
        tmp[k++] = nums[j++];
    }
    for (int m =0; m < tmp.length; m++) {
        nums[low + m] = tmp[m];
    }
}
```

+ 求逆序对

  ```java
  
  ```

##### 4. 快速排序

+ 平均时间复杂度O(nlogn)
+ 最好时间复杂度O(nlogn)
+ 最坏时间复杂度O(n^2)
  + 待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，这时的快速排序退化为冒泡排序。
+ 空间复杂度O(1)
+ 不稳定

```java
private void  quick_sort(int [] nums, int low, int high) {
    if (low >= high) return;
    int p = nums[low];
    int i = low;
    int j = high;
    while (i < j) {
        while (i < j && nums[j] >= p)
            j--;
        nums[i] = nums[j];
        while (i < j && nums[i] < p)
            i++;
        nums[j] = nums[i];
    }
    nums[i] = p;
    quick_sort(nums, low, i - 1);
    quick_sort(nums, i + 1, high);
}
```

##### 5. 堆排序（实现）

+ 时间复杂度O(nlogn)
+ 最坏最好都是
+  不稳定

```java
class Heap {
    public void heapSort(int[] arr) {
        buildHeap(arr);
        for(int i = arr.length - 1; i >= 1; i--) {
            swap(arr, 0, i);
            // 调整堆到最大堆
            heapify(arr, 0, i);
        }
    }
	
    // 建堆的时间复杂度为O(N) - 叠加
    private void buildHeap(int[] arr) {
        for (int i = (arr.length - 1) / 2; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
    }

    private void heapify(int[] arr, int index, int heapSize) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        int imax = index;
        if (left < heapSize && arr[left] > arr[imax]) imax = left;
        if (right < heapSize && arr[right] > arr[imax]) imax = right;
        if (imax != index) {
            swap(arr, imax, index);
            heapify(arr, imax, heapSize);
        }
    }

    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

#### 5. 树

##### 1. 重建二叉树

```java
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
    return reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1);
}

private TreeNode reConstructBinaryTree(int [] pre, int startPre, int endPre, int [] in, int startIn, int endIn) {
    if (startPre > endPre || startIn > endIn)
        return null;
    TreeNode root = new TreeNode(pre[startPre]);
    for (int i = startIn; i <= endIn; i++) {
        if (in[i] == root.val) {
            root.left = reConstructBinaryTree(pre,startPre + 1, i - startIn + startPre, in, startIn, i - 1);
            root.right = reConstructBinaryTree(pre, i - startIn + startPre + 1, endPre, in, i + 1, endIn);
            break;
        }
    }
    return root;
}
```

##### 2. 树的子结构

```java
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
    boolean res = false;
    if (root1 != null && root2 != null) {
        if (root1.val == root2.val)
            res = doseTree1haveTree2(root1, root2);
        if (!res)
            res = HasSubtree(root1.left, root2);
        if(!res)
            res = HasSubtree(root1.right, root2);
    }
    return res;
}

private boolean doseTree1haveTree2(TreeNode root1, TreeNode root2) {
    if (root2 == null)
        return true;
    if (root1 == null)
        return false;
    if (root1.val != root2.val)
        return false;
    return doseTree1haveTree2(root1.left, root2.left) &&
        doseTree1haveTree2(root1.right, root2.right);
}
```

##### 3. 二叉树的镜像

```java
public void Mirror(TreeNode root) {
    if (root == null || (root.left == null && root.right == null))
        return;
    TreeNode tmpNode = root.left;
    root.left = root.right;
    root.right = tmpNode;
    if (root.left != null)
        Mirror(root.left);
    if (root.right != null)
        Mirror(root.right);
}
```

##### 4. 从上往下打印二叉树(层次遍历)

```java
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    ArrayList<Integer> arr = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    if (root == null)
        return arr;
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        arr.add(node.val);
        if (node.left != null) 
            queue.offer(node.left);
        if (node.right != null)
            queue.offer(node.right);
    }
    return arr;
}
```



##### 5. 二叉搜索树的后序遍历序列



##### 6. 二叉树中和为某一值的路径

```java
private ArrayList<ArrayList<Integer>> listAll = new ArrayList<>();
private ArrayList<Integer> list = new ArrayList<>();

public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
    if (root == null)
        return listAll;
    list.add(root.val);
    target -= root.val;
    if (target == 0 && root.left == null && root.right == null)
        // 其实add加进去的是对象的一个引用, 如果重新new一个对象的话，则会将前面赋值进去的值覆盖。
        listAll.add(new ArrayList<Integer>(list));
    FindPath(root.left, target);
    FindPath(root.right, target);
    list.remove(list.size() - 1);
    return listAll;
}
```

##### 7. 二叉搜索树与双向链表

##### 8. 二叉树的深度

```java
public int TreeDepth(TreeNode root) {
    if (root == null)
        return 0;
    int left = TreeDepth(root.left);
    int right = TreeDepth(root.right);
    return Math.max(left, right) + 1;
}
```

##### 9. 平衡二叉树

```java
public boolean IsBalanced_Solution(TreeNode root) {
    if (root == null)
        return true;
    if (Math.abs(TreeDepth(root.left) - TreeDepth(root.right)) > 1)
        return false;
    return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
}

private int TreeDepth(TreeNode root) {
    if (root == null)
        return 0;
    int left = TreeDepth(root.left);
    int right = TreeDepth(root.right);
    return Math.max(left, right) + 1;
}
```

##### 10. 二叉树的下一个结点



##### 11. 对称的二叉树

##### 12. 把二叉树打印成多行

##### 13. 二叉搜索树的第k个结点

```java
TreeNode KthNode(TreeNode pRoot, int k) {
    if (pRoot == null || k <= 0)
        return null;
    Stack<TreeNode> s = new Stack<>();
    int count = 0;
    TreeNode node = pRoot;
    while (node != null || !s.isEmpty()) {
        while (node != null) {
            s.push(node);
            node = node.left;
        }
        node = s.pop();
        count++;
        if (count == k) return node;
        node = node.right;
    }
    return null;
}
```

##### 14. 树的前序遍历，中序遍历，后序遍历的递归和非递归实现

```java
// 第一题：非递归实现二叉树的前序遍历
// 利用栈实现 根-左-右
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        list.add(node.val);
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push((node.left));
    }
    return list;
}

// 第二题：非递归实现二叉树的后序遍历
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) return list;
    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        list.add(node.val);
        if (node.left != null) stack.push(node.left);
        if (node.right != null) stack.push(node.right);
    }
    Collections.reverse(list);
    return list;
}

// 第三题；非递归实现二叉树的中序遍历
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        list.add(cur.val);
        cur = cur.right;
    }
    return list;
}
```





## ====

快速排序，归并排序，堆排序

手动实现深度搜索和广度搜索算法

**一个二叉树上求两个节点之间路径长度的最大值**

广搜的话怎么搜，能不能在搜索岛屿的时候标号

反转一个句子当中的单词的顺序

给一个矩阵，找出最大连通分量具有的元素数。



一个类中三个方***被三个不同的线程调用，要求按照指定的方式运行。比如三个方法分别打印ABC，外部调用按照CBA的顺序执行线程，要求最终输出结果还是ABC。



完全背包问题，背包容量量远⼤大于物品重量量，怎么优化



hive

窗口函数的应用

+ **每个用户截止到每月为止的最大单月访问次数和累计到该月的总访问次数**

```sql
select 
	a.name,a.month,a.pv,
	max(a.pv)over(partion by a.name order by a.month) as maxpv,
	sum(a.pv)over(partion by a.name order by a.month) as sumpv
from(
	select t.name,t.month,sum(t.pv) as pv
    from test as t
    group by t.name,t.month
) as a
```

+ **求topk**

```sql
select t.*
from 
(select 
	school, grade, course, score,
	row_number()over(partition by chool, grade, course order score desc) as rank
from test2) as t
where rank <= 3;
```



阿里一面（35min）

+ 项目
+ hadoop的基本组件详细介绍一下
+ zk的实现原理
+ zk如何实现分布式锁
+ 并发编程如何实现
+ 生产者，消费者模式的具体实现是什么
+ mysql的事务隔离级别是什么
+ 红黑树知道吗？大概说一下



阿里二面（30min）

+ 项目
+ hive的优点，为什么要使用hive
+ **tcp协议的重传机制**
+ 问了转行的原因



阿里三面（两个半小时）

+ 算法题一，在数组中随机选取是三个数，越大的数出现的频率越大
+ 算法题二，根据字典来遍历输入字符串
+ 算法题三，岛屿问题
+ **T 的含义是什么**
+ 项目介绍一下

+ 数据流中的中位数是怎么找到的





















