# 变量的解构赋值



## 数组的解构赋值

### 基本用法

ES6 中允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这个被称为解构

```js
let [a, b, c] = [1, 2, 3];
```

以上表达式，是值可以从数组中提取值，按照对应的位置，来为变量赋值

+ 只要等号两边的模式相同，左边的变量就会被赋予对应的值。

  ```js
  let [x, , y] = [1, 2, 3];
  x // 1
  y // 3
  
  let [head, ...tail] = [1, 2, 3, 4];
  head // 1
  tail // [2, 3, 4]
  
  let [x, y, ...z] = ['a'];
  x // "a"
  y // undefined
  z // []
  ```

+ 如果解构不成功，变量的值为undefined

  ```js
  let [foo] = [];
  let [bar, foo] = [1];
  ```

+ 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

  ```js
  let [x, y] = [1, 2, 3];
  x // 1
  y // 2
  
  let [a, [b], d] = [1, [2, 3], 4];
  a // 1
  b // 2
  d // 4
  ```

+ 如果等号的右边不是数组，那么将会报错。

  ```js
  // 报错
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
  ```



### 默认值

解构赋值允许指定默认值

```js
let [y = true] = []
console.log(y) // true

let [x, y = 'b'] = [1,undefined]
console.log(x) // 1
console.log(y) // b
```

注意：ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。

```js
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
```



## 对象的解构赋值

### 基本用法

解构不仅可以用在数组，还可以用在对象中

```js
let {foo, bar} = {foo: 'foo', bar: 'bar'}
console.log(foo) // 'foo'
console.log(bar) // 'bar'
```

+ 数组解构和对象解构中的不同点

  + 数组的元素是按顺序排的，变量的取值是取决于位置
  + 对象的属性没有次序，变量名必须同属性名相同，才能取到值

  ```js
  let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
  foo // "aaa"
  bar // "bbb"
  ```

+ 如果解构失败，变量的值为undefined

  ```js
  let {foo} = {bar: 'baz'};
  foo // undefined
  ```

+ 对象的解构能够很方便的将现有对象的方法，赋值给变量

  ```js
  const {log} = console
  log('hello') // hello
  
  const {sin, cos, tan} = Math
  ```

+ 对象解构的内部机制（参见《对象的扩展》一章）

  + 先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

  ```js
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  foo // error: foo is not defined
  ```

+ 解构可用于嵌套对象

  ```js
  let obj = {
    p: [
      'Hello',
      { y: 'World' }
    ]
  };
  
  let { p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  ```

  其中，p为模式，而非变量（参考上一点，对象解构的内部机制）。如果要对p也做变量赋值，可以写成下面这样。

  ```js
  let obj = {
    p: [
      'Hello',
      { y: 'World' }
    ]
  };
  //蓝色的部分才是变量
  let { p:ppp, p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  p // ["Hello", {y: "World"}]
  ```

  ```js
  const node = {
    loc: {
      start: {
        line: 1,
        column: 5
      }
    }
  };
  
  let { loc, loc: { start }, loc: { start: { line }} } = node;
  line // 1
  loc  // Object {start: Object}
  start // Object {line: 1, column: 5}
  ```

  ```js
  let obj = {};
  let arr = [];
  
  ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
  
  obj // {prop:123}
  arr // [true]
  ```

  

### 默认值

对象解构也可以使用默认值

```js
let {x, y = 5} = {x: 1}
console.log(x) // 1
console.log(y) // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5
```

+ 默认值生效的条件是，对象的属性值严格等于`undefined`。

  ```js
  var {x = 3} = {x: undefined};
  x // 3
  
  var {x = 3} = {x: null};
  x // null
  ```



### 注意点

+ 对已经声明的变量用于解构赋值，要小心

  ```js
  //错误写法
  let x
  {x} = {x: 1} //SyntaxError: Unexpected token =
  
  //正确写法
  let x
  ({x} = {x: 1})
  console.log(x) // 1
  ```

+ 数组是对象，可以进行对象解构

  ```js
  let arr = [1, 2, 3]
  let {0: first, [arr.length - 1]: last} = arr
  console.log(first) // 1
  console.log(last) // 3
  ```

  其中，`[arr.length - 1]` 方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。



## 字符串的解构赋值

字符串也可以解构赋值。这是因为此时，**字符串被转换成了一个类似数组的对象**。

```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

```javascript
let {length : len} = 'hello';
len // 5
```



## 数值和布尔值的解构赋值

解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

```js
let {toString: s} = 123
console.log(s === Number.prototype.toString); // true

let {toString: ss} = true
console.log(ss === Boolean.prototype.toString) // true
```

注：null 和 undefined 无法转为对象，因此解构会失败



## 函数参数的解构赋值

在这个函数`move`中，参数是一个对象，通过对这个对象进行解构，从而得到变量`x` 和 `y` ,如果解构失败，则使用默认值，`undefined` 会触发函数参数的默认值。

```js
function move ({x = 0, y = 0} = {}) {
    return [x, y]
}
let res
res = move({x: 1, y: 2}) // [1,2]
res = move({x: 1}) // [1,0]
res = move({}) //[0,0]
res = move() //[0,0]
```



在这个函数 `move` 中，是为 `move` 的参数指定默认值，而不是为变量指定默认值

```js
function move ({x, y} = {x: 0, y: 0}) {
    return [x, y]
}
let res
res = move({x: 1, y: 2}) // [1,2]
res = move({x: 1}) // [ 1, undefined ]
res = move({}) //[ undefined, undefined ]
res = move() //[0,0]
```



## 用途

1. **交换变量的值**

   ```js
   let x = 1
   let y = 2
   ;[x, y] = [y, x]
   
   console.log(x) // 2
   console.log(y) // 1
   ```

2. **从函数返回多个值**

   ```js
   function example () {
       return [1, 2, 3]
   }
   let [a, b, c] = example()
   
   
   function example2 () {
       return {
           foo: 'foo',
           bar: 'bar'
       }
   }
   let {foo, bar} = example2()
   ```

3. **函数参数的定义**

   解构赋值可以方便地将一组参数与变量名对应起来。

   ```js
   //参数是一组有序的值
   function f ([x, y, z]) {
       // ...
   }
   f([1, 2, 3])
   
   //参数是一组无序的值
   function f1 ({x, y, z}) {
       // ...
   }
   f1({x: 1, y: 2, z: 3 })
   ```

4. **提取 `JSON` 数据**

   ```js
   let jsonData = {
       "id": 42,
       "status": "OK",
       "data": [867, 5309]
   }
   let {id, status, data: number} = jsonData;
   console.log(id, status, number); // 42 'OK' [867, 5309]
   ```

5. **函数参数的默认值**

6. **遍历 Map 结构**

   任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

   ```js
   const map = new Map()
   map.set('first', 'hello')
   map.set('second', 'world')
   
   // for...of 变量map 返回的是一个key:value的数组啊
   for (let [key, value] of map) {
       console.log(key + ' is ' + value)
   }
   ```

   如果只想获得键值或者键名

   ```javascript
   // 获取键名
   for (let [key] of map) {
     // ...
   }
   
   // 获取键值
   for (let [, value] of map) {
     // ...
   }
   ```

7. **输入模块的指定方法**

   ```js
   const { SourceMapConsumer, SourceNode } = require("source-map");
   ```

   ​	













