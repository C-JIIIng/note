t 线程等待时间超过了 n 毫秒

# 并发编程

## 1. 进程与线程

### 1.1 进程与线程

+ 进程
  + 程序是由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至cpu，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存，管理IO的
  + 当一个程序被运行，从磁盘加载这个程序的代码至内存，这是就开启了一个进程
  + 进程就可以视为程序的一个实例，大部分程序可以同时运行多个实例进程
+ 线程
  + 一个进程之内可以分为一到多个线程
  + 一个线程就是一个指令流，将指令流中 一条条指令以一定的顺序交给CPU执行
  + java中，线程是最小的调度单位，进程是资源分配的最小单位
+ 区别
  + 进程基本上是独立的，而线程存在于进程之中，是进程的一个子集
  + 进程拥有共享资源，如内存空间等，供其内部线程使用
  + 进程之间的通讯较为复杂
    + 同一台计算机的进程通信称为IPC
    + 不同计算机之间的进程通讯，需要通过网路，并遵守共同的协议，如HTTP
  + 线程的通讯较为简单，因为他们是共享进程内的内存，多个线程可以访问同一个共享变量
  + 线程的上下文切换成本一般比进程的低

### 1.2 并行与并发

+ 单核cpu
  + 线程实际上串行执行的，微观串行，宏观并行
  + **线程轮流使用cpu的做法称为并**发，concurrent
+ 多核cpu
  + 每个core都可以调度运行线程，线程是并行的，parallel

### 1.3 ==(效率)应用==

#### 异步调用

以调用方角度来看

+ 需要等待结果返回，才能继续运行的就是同步
+ 不需要等待结果返回，就能继续运行就是异步

#### 提高效率

+ 单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活
+ 多核cpu可以并行跑多个线程，但能否程序运行效率还是要分情况的
  + 有些任务，能有拆分，可以提高运行效率，但是并不是所有任务都可以拆分的（阿姆达尔定律）
  + 也不是所有的任务都需要拆分
+ IO操作不占用cpu，只是我们一般拷贝文件使用的是阻塞IO，这是相当于线程虽然不用cpu，但需要一直等待IO结束，没有充分利用线程，所有才有了非阻塞IO和异步IO优化



## 2. Java线程

> + 创建和运行线程
> + 查看线程
> + 线程API
> + 线程状态

### 2.1 创建和运行线程

#### 方法一：直接使用 Thread

```java
// 创建线程对象
Thread t = new Thread() {
	public void run() {
	// 要执行的任务
	}
};
// 启动线程
t.start();
```

```java
// 构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread("t1") {
	@Override
	// run 方法内实现了要执行的任务
	public void run() {
		log.debug("hello");
	}
};
t1.start();
```

> 19:19:00 [t1] c.ThreadStarter - hello

#### 方法二：使用Runnable 配合 Thread

把【线程】和【任务】（要执行的代码）分开

+ Thread 代表线程
+ Runnable 可运行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable() {
	public void run(){
	// 要执行的任务
	}
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

```java
// 创建任务对象
Runnable task2 = new Runnable() {
	@Override
	public void run() {
		log.debug("hello");
	}
};

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

> 19:19:00 [t2] c.ThreadStarter - hello

```java
// 创建任务对象
Runnable task2 = () -> log.debug("hello");

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

#### Thread 和 Runnable 的关系

+ 源码

  + thread类实现了runnable接口，重写run方法，将runnable 对象传入 Thread 构造函数中，会赋值给Thread中的一个target对象，当thread执行run方法时，会判断这个target是否为空，不为空，则执行该对象的run方法

  ```java
  private Runnable target;
  // 这个target是外部传来的 runnable 对象
  this.target = target;
  
  public void run() {
      if (target != null) {
          target.run();
      }
  }
  ```

+ 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了
+ 用Runnable 更容易与线程池等高级 API 配合
+ 用Runnable 让任务类脱离了 Thread 继承体系，更灵活

#### 方法三：FutureTask 配合 Thread

FutureTask 能够接收 Callable 类型的参数，用来处理**有返回结果**的情况

```java
// 创建任务对象
FutureTask<Integer> task3 = new FutureTask<>(() -> {
	log.debug("hello");
	return 100;
});
// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, "t3").start();
// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
log.debug("结果是:{}", result);
```

> 19:22:27 [t3] c.ThreadStarter - hello
> 19:22:27 [main] c.ThreadStarter - 结果是:100

+ 源码
  + FutureTask 实现了一个 RunnableFuture 接口
  + RunnableFuture 接口 实现了 Runnable、Future接口
  + Future接口提供一个get方法来返回结果
  + FutureTask 结合一个 Callable 接口，callable 接口有一个call方法来实现返回结果
  + FutureTask 接收一个 Callable 对象，用户重写了call 方法（有返回值），FutureTask重写了 run方法，中间调用了call方法，call方法将结果复制给一个outcome变量，用于后续的获取。Thread 依旧会将FutureTask(继承了Runnable类) 赋值给 target，然后调用了run，调用了call
  + FutureTask 提供了 get 方法来获取到 call 的返回值。

### 2.3 查看进程线程的方法

+ windows
  + 任务管理器可以查看进程和线程数，也可以用来杀死进程
  + tasklist 查看进程
  + taskkill 杀死进程
+ linux
  + ps -fe 查看所有进程
  + ps -fT -p <PID> 查看某个进程（PID）的所有线程
  + kill 杀死进程
  + top 按大写 H 切换是否显示线程
  + top -H -p <PID> 查看某个进程（PID）的所有线程
+ Java
  + jps 命令查看所有 Java 进程
  + jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
  + jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

### 2.4 ==原理之线程运行==

#### 栈与栈帧

java虚拟机栈，线程私有，是描述 **Java 方法执行的内存模型**，每个方法在执行的同时都会创建一个**栈帧（**Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

#### 线程上下文切换（Thread Context Switch）

cpu不再执行当前的线程，而执行另一个线程的代码

+ 线程的cpu时间片用完
+ **垃圾回收**
+ 有更高优先级的线程需要运行
+ 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法

### 2.5. 常见方法

#### 2.5.1 start 和 run

**调用run方法**

```java
public static void main(String[] args) {
	Thread t1 = new Thread("t1") {
		@Override
		public void run() {
		log.debug(Thread.currentThread().getName());
		FileReader.read(Constants.MP4_FULL_PATH);
		}
	};
	t1.run();
	log.debug("do other things ...");
}
```

> 19:39:14 [main] c.TestStart - main
> 19:39:14 [main] c.FileReader - read [1.mp4] start ...
> 19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms
> 19:39:18 [main] c.TestStart - do other things ...

程序仍在 main 线程运行，FileReader.read() 方法调用还是同步的

**调用strat**

```java
// 将上述代码的t1.run() 改为
t1.start();
```

> 19:41:30 [main] c.TestStart - do other things ...
> 19:41:30 [t1] c.TestStart - t1
> 19:41:30 [t1] c.FileReader - read [1.mp4] start ...
> 19:41:35 [t1] c.FileReader - read [1.mp4] end ... cost: 4542 ms

程序在 t1 线程运行， FileReader.read() 方法调用是异步的

**小结**

+ 直接调用run是在主线程中执行run，没有启动新的线程
+ 使用start是启动新的线程，通过新的线程间接执行了run中的代码

#### 2.5.2 sleep 和 yield

**sleep**

+ 调用sleep会让当前线程从 **Running 进入 Timed Wating 状态（阻塞）**
+ 其他线程可以使用 interrupt 方法打断正在睡眠的线程，这是 sleep 方法会抛出 `InterruptedException` ，会清除打断标记
+ 睡眠结束后的线程未必会立刻得到执行（要看任务调度器是否分到时间片给这个线程）
+ 建议使用 TimeUnit 的sleep 代替 Thread 的sleep 来获得更好的可读性

**yield**

+ 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其他线程
+ 但是具体的实现依赖于操作系统的任务调度器（也即线程未必能够成功的让出cpu）

**线程优先级**

+ 线程优先级会**提示**调度器优先调度该线程，但是它仅仅只是一个提示，调度器可以忽略它
+ 如果cpu较忙，name优先级较高的线程会获得更多的时间片，但是如果cpu闲时，优先级几乎没作用

##### ==(限制)应用：利用sleep来限制cpu的使用==

在没有利用cpu来计算是，不要让 while（true）空转浪费 cpu，这时可以使用yield 或 sleep 来让出cpu的使用权给其他进程

```java
while(true) {
	try {
		Thread.sleep(50);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
}
```

#### 2.5.3 join

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待 n 毫秒

##### ==(同步)应用：应用之同步==

以调用方角度来讲，如果

+ 需要等待结果返回，才能继续运行就是同步
+ 不需要等待结果返回，就能继续运行就是异步

```java
static int r = 0;
public static void main(String[] args) throws InterruptedException {
	test1();
}
private static void test1() throws InterruptedException {
	log.debug("开始");
	Thread t1 = new Thread(() -> {
		log.debug("开始");
		sleep(1);
		log.debug("结束");
		r = 10;
	});
	t1.start();
    t1.join();
	log.debug("结果为:{}", r);
	log.debug("结束");
}
```

![image-20200302214843282](D:\Desktop\面试\img\image-20200302214843282.png)

**等待多个结果**

问，下面代码 cost 大约多少秒？

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
    });
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005

分析

+ 第一个 join：等待 t1时，t2并没有停止，而在运行
+ 第二个 join：1s后，执行到此，t2也运行了1s，因此也只需要等待1s
+ 如果颠倒两个join，结果也是一样的

![image-20200302215503406](D:\Desktop\面试\img\image-20200302215503406.png)

##### 有时效的join

等够时间

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test3();
}
public static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	long start = System.currentTimeMillis();
	t1.start();
    // 线程执行结束会导致 join 结束
	t1.join(1500);
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:48:01.320 [main] c.TestJoin - r1: 10 r2: 0 cost: 1010

没等够时间

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test3();
}
public static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(2);
		r1 = 10;
	});
	long start = System.currentTimeMillis();
	t1.start();
    // 线程执行结束会导致 join 结束
	t1.join(1500);
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502

#### 2.5.4 interrupt()

##### 打断 sleep、wait、join的线程

这几个方法都会让线程进入阻塞状态

打断 sleep 的线程，会清空打断状态，以sleep为例

```java
private static void test1() throws InterruptedException {
	Thread t1 = new Thread(()->{
		sleep(1);
	}, "t1");
	t1.start();
	sleep(0.5);
	t1.interrupt();
	log.debug(" 打断状态: {}", t1.isInterrupted());
}
```

> java.lang.InterruptedException: sleep interrupted
> at java.lang.Thread.sleep(Native Method)
> at java.lang.Thread.sleep(Thread.java:340)
> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
> at java.lang.Thread.run(Thread.java:745)
> 21:18:10.374 [main] c.TestInterrupt - **打断状态: false**

##### 打断正常运行的线程

打断正常运行的线程，不会清空打断状态

```java
private static void test2() throws InterruptedException {
	Thread t2 = new Thread(()->{
        while(true) {
            Thread current = Thread.currentThread();
            boolean interrupted = current.isInterrupted();
            if(interrupted) {
                log.debug(" 打断状态: {}", interrupted);
                break;
            }
		}
	}, "t2");
	t2.start();
	sleep(0.5);
	t2.interrupt();
}
```

> 20:57:37.964 [t2] c.TestInterrupt - **打断状态: true**

可以使用 isInterrupt() 方法来获取线程的打断状态

##### ==(终止模式)模式：两阶段终止模式==

在一个线程T1中如何【优雅】终止线程T2，这里的【优雅】是指给T2一个料理后事的机会

**1. 错误的思路**

+ 使用线程对象的 stop() 方法停止线程
  + stop方法会真正杀死线程，如果这是线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程将永远无法获得锁
+ 使用 System,exit(init) 方法
  + 目的仅是停止一个线程，但这种作法会让整个程序都停止

**2. 两阶段停止模式**

![image-20200302223920128](D:\Desktop\面试\img\image-20200302223920128.png)

**2.1 利用interrupt**

interrupt可以打断正在执行的线程，无论这个线程是在sleep、wait，还是正常运行

```java
class TPTInterrupt {
    private Thread thread;
    
    public void start() {
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (current.isInterrupted()) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                    // 当打断sleep时，打断标记会被清除，导致由重新进行监控，所以在捕捉到打断异常时，需要再次打断，来获取打断标记
                    current.interrupt();
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        thread.interrupt();
    }
}
```

调用

```java
TPTInterrupt t = new TPTInterrupt();
t.start();
Thread.sleep(3500);
log.debug("stop");
t.stop();
```

##### 打断 park 线程

打断park线程，不会清空打断状态

```java
private static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		log.debug("park...");
		LockSupport.park();
		log.debug("unpark...");
		log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
	}, "t1");
	t1.start();
	sleep(0.5);
	t1.interrupt();
}
```

> 21:11:52.795 [t1] c.TestInterrupt - park...
> 21:11:53.295 [t1] c.TestInterrupt - unpark...
> 21:11:53.295 [t1] c.TestInterrupt - 打断状态：true

如果打断标记为true，则park会失效

```java
private static void test4() {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5; i++) {
			log.debug("park...");
			LockSupport.park();
			log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
		}
	});
	t1.start();
	sleep(1);
	t1.interrupt();
}
```

> 21:13:48.783 [Thread-0] c.TestInterrupt - park...
> 21:13:49.809 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.812 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true

**可以使用 Thread.interrupted 来清除打断标记，与 isInterrupted 都是可以获取打断标志位，不同的是，前者会清除标记位，后者不会清除标记位，按需使用**

### 2.6 守护线程

默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束

```java
log.debug("开始运行...");
Thread t1 = new Thread(() -> {
	log.debug("开始运行...");
	sleep(2);
	log.debug("运行结束...");
	}, "daemon");
// 设置该线程为守护线程
t1.setDaemon(true);
t1.start();
sleep(1);
log.debug("运行结束...");
```

> 08:26:38.123 [main] c.TestDaemon - 开始运行...
> 08:26:38.213 [daemon] c.TestDaemon - 开始运行...
> 08:26:39.215 [main] c.TestDaemon - 运行结束...

**注意**

+ 垃圾回收器线程就是一种守护线程

### 2.7 线程状态

#### 2.7.1 五种状态

在操作系统层面来描述

![image-20200302233901360](D:\Desktop\面试\img\image-20200302233901360.png)

+ 初始状态：仅是在语言层面创建了线程对象，还未与操作系统线程关联
+ 可运行状态：（就绪状态）指该程序已经被创建（与操作系统线程关联），可以由CPU调度执行
+ 运行状态：获取了CPU事件片运行中的状态
  + 当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换
+ 阻塞状态：
  + 如果调用了阻塞API，如IO读写文件，这是该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态
  + 等IO操作结束时，会由操作系统唤醒阻塞的线程，转换至可运行状态
  + 与可运行状态的区别是，对阻塞状态的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们
+ 终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态

#### 2.7.2 六种状态

这是从 Java API 层面来描述的

根据 Thread.State 枚举，分为六种状态

![image-20200302234759344](D:\Desktop\面试\img\image-20200302234759344.png)

+ `NEW`：线程刚被创建，还没有调用 `start()` 方法
+ `RUNNABLE`：当调用 `start()` 方法之后，注意，Java API 层面 的 `RUNNABLE` 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】
+ `BLOCKED` ， `WAITING` ， `TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述
+ `TERMINATED` 当线程代码运行结束

### 2.8 ==(统筹)应用：烧水泡茶==

```java
Thread t1 = new Thread(() -> {
	log.debug("洗水壶");
	sleep(1);
	log.debug("烧开水");
	sleep(15);
}, "老王");

Thread t2 = new Thread(() -> {
	log.debug("洗茶壶");
	sleep(1);
	log.debug("洗茶杯");
	sleep(2);
	log.debug("拿茶叶");
	sleep(1);
	try {
		t1.join();
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	log.debug("泡茶");
}, "小王");

t1.start();
t2.start();
```

> 19:19:37.547 [小王] c.TestMakeTea - 洗茶壶
> 19:19:37.547 [老王] c.TestMakeTea - 洗水壶
> 19:19:38.552 [小王] c.TestMakeTea - 洗茶杯
> 19:19:38.552 [老王] c.TestMakeTea - 烧开水
> 19:19:40.553 [小王] c.TestMakeTea - 拿茶叶
> 19:19:53.553 [小王] c.TestMakeTea - 泡茶

+ 上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶呢？代码最好能适应两种情况
+ 上面的两个线程其实是各执行各的，如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡茶呢

### 本章小结

+ 线程的创建
  + thread，runnable，futureTask
+ 线程重要api，start、run、sleep、join、interrupt
+ 线程状态
+ 应用方面
  + 异步调用：主线程执行期间，其他线程异步执行
  + 提高效率：并行计算，缩短运算时间
  + 同步等待：join
  + 统筹规划：合理使用线程，得到最优效果
+ 原理方面
  + 线程运行流程：栈、栈帧、上下文切换、程序计数器
  + Thread两种创建方式的源码
+ 模式方面
  + 终止模式之两阶段终止



## 3.共享模型之管程

> + 共享问题
> + synchronized
> + 线程安全分析
> + Monitor
> + wait/notify
> + 线程状态转换
> + 活跃性
> + Lock

### 3.1 共享问题

java程序是由指令和数据组成的，一条java代码，在底层可能不是一个原子操作，同时cpu采用分时系统，会导致线程之间的上下文切换，这时就可能导致一个共享资源的数据不一致性问题

#### 临界区

+ 一个程序运行多个线程本身是没有问题的
+ 问题出在多个线程访问**共享资源**
  + 多个线程读共享资源其实也没有问题
  + 在多个线程对共享资源读写操作是发生**指令交错**，就会出现问题。
+ **一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区**

#### 竞态条件

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称为发生了竞态条件

### 3.2 sychronized解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的

+ 阻塞式的解决方案：synchronized，Lock
+ 非阻塞式的解决方案：原子变量



sychronized，俗称【对象锁】，他采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其他线程再想获取这个【对象锁】时就会被阻塞。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

> 注：
>
> 虽然java中互斥和同步都可以采用sychronized关键字来完成，但是它们还是有区别的
>
> + **互斥**是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
> + **同步**是由于线程执行的先后、顺序不同、需要一个线程等待其他线程运行到某个点（协作）

语法：

```java
synchronized(对象) {// 线程1， 线程2(blocked)
	临界区
}
```

**思考**

+ **synchronized 实际是用==对象锁==保证了==临界区内代码的原子性==**，临界区内的代码对外是不可分割的，不会被线程切换所打断。

**锁对象**

```java
public static sychronized void fun(){
    // 锁住的是Class对象
} 
public sychronized void fun(){
    // 锁住的是this对象
} 
public void fun(){
    sychronized(obj) {
        // 锁住obj对象
    }
}
```



### 3.3 变量的线程安全性分析

#### 3.3.1 成员变量和静态变量是否线程安全？

+ 如果他们没有共享，则线程安全
+ 如果他们被共享了，根据他们的状态是否能够改变，有分为两种情况
  + 如果只是读操作，则线程安全
  + 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 3.3.2 局部变量是够线程安全？

+ 局部变量是线程安全的
+ 但是局部变量引用的对象则未必
  +  如果这个对象没有逃离方法的作用范围，他是线程安全的
  + 如果该对象逃离方法的作用范围，需要考虑线程安全

#### 3.3.3 局部变量线程安全分析

##### 局部变量是线程安全的

```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享.

![image-20200304153505585](D:\Desktop\面试\img\image-20200304153505585.png)

##### **局部变量的引用稍有不同**

先看一个成员变量的例子

```java
class ThreadUnsafe {
	ArrayList<String> list = new ArrayList<>();
	public void method1(int loopNumber) {
		for (int i = 0; i < loopNumber; i++) {
		// { 临界区, 会产生竞态条件
			method2();
			method3();
            // } 临界区
		}
	}
	private void method2() {
		list.add("1");
	}
	private void method3() {
		list.remove(0);
	}
}
```

执行

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
	ThreadUnsafe test = new ThreadUnsafe();
	for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：

> Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
> at java.util.ArrayList.rangeCheck(ArrayList.java:657)
> at java.util.ArrayList.remove(ArrayList.java:496)
> at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35)
> at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26)
> at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14)
> at java.lang.Thread.run(Thread.java:748)

分析：

+ 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量
+ method3 与 method2 分析相同

![image-20200304161335483](D:\Desktop\面试\img\image-20200304161335483.png)

**将list修改为局部变量**

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
    	list.add("1");
    }
    private void method3(ArrayList<String> list) {
    	list.remove(0);
    }
}
```

那么就不会有上述问题了

分析：

+ list 是局部变量，每个线程调用时会创建其不同实例，没有共享
+ 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象
+ method3 的参数分析与 method2 相同

![image-20200304161609436](D:\Desktop\面试\img\image-20200304161609436.png)

方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 **public** 会不会代理线程安全问题？

+ 情况1：有其它线程调用 method2 和 method3
+ 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即

```java
class ThreadSafe {
	public final void method1(int loopNumber) {
		ArrayList<String> list = new ArrayList<>();
		for (int i = 0; i < loopNumber; i++) {
			method2(list);
			method3(list);
		}
	}
    
	public void method2(ArrayList<String> list) {
		list.add("1");
    }
    public void method3(ArrayList<String> list) {
    	list.remove(0);
    }
}

class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```



>  从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】



### 3.4 Monitor概念

#### 3.4.1 Java 对象头

Java 对象

+ 对象头
  + markword
  + klass word
    + 指向类的指针
+ 实例数据
+ 对齐填充字节

普通对象

![image-20200305215133520](D:\Desktop\面试\img\image-20200305215133520.png)

数组对象

![image-20200305215201677](D:\Desktop\面试\img\image-20200305215201677.png)

其中markword 结构为（64位）

![image-20200305215241575](D:\Desktop\面试\img\image-20200305215241575.png)



#### 3.4.2 Monitor 原理

Monitor -  管程 -  监视器

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁之后，该对象中的Mark Word 中就被设置指向 Monitor 对象的指针

![image-20200305215558821](D:\Desktop\面试\img\image-20200305215558821.png)

+ 刚开始的 Monitor 中的 Owner 为 null
+ 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一
  个 Owner
+ 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入
  EntryList BLOCKED
+ Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的
+ 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析

> 注意：
>
> + synchronized 必须是进入同一个对象的 monitor 才有上述的效果
> + 不加 synchronized 的对象不会关联监视器，不遵从以上规则

#### 3.4.3  synchronized 原理进阶

##### 1. 轻量级锁

轻量级锁的**使用场景**：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化

轻量级锁对使用者是透明的，即语法仍是 sychronized

假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
    	// 同步块 A
    	method2();
    }
}
public static void method2() {
    synchronized( obj ) {
    	// 同步块 B
    }
}
```

+ **创建锁记录（Lock Record）对象**，每个线程的栈帧都会包含一个锁对象的结构，内部可以存储锁对象的 Mark Word

  ![image-20200305222119612](D:\Desktop\面试\img\image-20200305222119612.png)

+ 让锁记录中 Object reference 指向锁对象，并尝试用 **cas** 替换 object 的 mark word，将 mark word 的值存入锁记录

  ![image-20200305222749774](D:\Desktop\面试\img\image-20200305222749774.png)

+ 如果 cas 替换成功，对象头中存储了 **锁记录地址和状态 00 **，表示由该线程给对象加锁

  ![image-20200305222849667](D:\Desktop\面试\img\image-20200305222849667.png)

+ 如果 cas 替换失败，有两种情况

  + 如果是其他线程已经持有了该 Object 的轻量级锁，这是表明有竞争，进入锁膨胀过程
  + 如果是自己执行了synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

  ![image-20200305223158073](D:\Desktop\面试\img\image-20200305223158073.png)

+ 当退出 sychronized 代码块（解锁时），如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

  ![image-20200305223323979](D:\Desktop\面试\img\image-20200305223323979.png)

+ 当退出 sychronized 代码块，锁记录的值不为null，这时使用cas 将 mark word 的值恢复给对象头

  + 成功，表明解锁成功
  + 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁的解锁流程。

##### 2. 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
    	// 同步块
    }
}
```

+ 当 Thread-1 进行轻量级加锁时，Thread-0已经对这个对象加了轻量级锁

  ![image-20200305224744162](D:\Desktop\面试\img\image-20200305224744162.png)

+ 这时Thread-1加轻量级锁失败，进入锁膨胀流程

  + 即为Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址
  + 然后自己进入 Monitor 的 EntryList BLOCKED

  ![image-20200305224934741](D:\Desktop\面试\img\image-20200305224934741.png)

+ 当Thread-0退出同步块解锁时，使用cas将Mark Word 的值恢复给对象块，失败。这时会进入重量级锁解锁流程，即按照Monitor 地址找到Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程

##### 3.自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞（阻塞就是上下文切换过程，会耗费cpu）

**自旋成功**

![image-20200305230652826](D:\Desktop\面试\img\image-20200305230652826.png)

**自旋失败**

![image-20200305230713139](D:\Desktop\面试\img\image-20200305230713139.png)

+ 自旋会占用cpu时间，单核cpu自旋就是浪费，只有多核cpu自旋才能发挥优势
+ 在java6 之后自旋是自适应的
+ java 7 之后不能控制是否开启自旋

##### 4.偏向锁

轻量级锁在没有竞争时，每次重入仍然需要执行cas操作

java6中引入了偏向锁来进一步优化：只有第一次使用cas将线程ID 设置到对象的 MarkWord 头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。

###### 偏向状态

Java对象头中 mark word 格式

![image-20200305234400291](D:\Desktop\面试\img\image-20200305234400291.png)

一个对象创建时

+ 如果开启了偏向锁（默认是开启的），那么对象创建后，markword的值为0x05，即最后三位为101，这是他的thread，epoch，age都为0
+ 偏向锁是默认延迟的，不会在程序启动时立即生效
+ 如果没有开启偏向锁，那么创建对象后，maekword的值为0x01，即最后3位为001，这是他的hashcode、age都为0，第一次用到hashcode时才会赋值（使用hashcode之后，会禁用偏向锁）

###### 撤销偏向锁

+ 调用对象hashcode
  + 调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销
  + 轻量级锁会在**锁记录**中记录 hashCode
  + 重量级锁会在 **Monitor** 中记录 hashCode
+ 其他线程使用对象
+ 调用wait/notify（需要配合一个Object Monitor 一起使用）

###### 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID

当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至
加锁线程

###### 批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象
都会变为不可偏向的，新建的对象也是不可偏向的

### 3.5 wait notify

#### 3.5.1 wait/notify 原理介绍

![image-20200306002500752](D:\Desktop\面试\img\image-20200306002500752.png)

+ Owner 线程发现条件不满足时，调用wait方法，即可进入waitset变为waiting状态
+ BLOCKED 和 WAITING 的线程都是处于阻塞状态，都不占用cpu时间片
+ BLOCKED 线程会在Owner 线程释放锁时唤醒
+ WAITING 线程会在Owner线程调用notify 或 notifyall时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争

#### 3.5.2 API介绍

+ obj.wait() 让进入 object 监视器的线程到 waitSet 等待
+ obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒
+ obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒

它们都是线程之间进行**协作**的手段，都属于 **Object 对象的方法**。必须获**得此对象的锁**，才能调用这几个方法

#### 3.5.3 wait notify 的正确姿势

**sleep(long n) 和 wait(long n) 的区别**

+ sleep是Thread的方法，而wait是Object的方法
+ sleep不需要强制和synchronized配合使用，但是wait需要
+ sleep在睡眠的同时，不会释放锁对象，但是wait在等待的时候会释放锁对象
+ 两者都会使得线程进入TIMED_WAITING 状态

```java
synchronized(lock) {
    while(条件不成立) {
    	lock.wait();
    }
    // 干活
}

//另一个线程
synchronized(lock) {
	lock.notifyAll();
}
```



### 3.6 ==(同步模式)模式：保护性暂停==

#### 3.6.1 定义

即 Guarded Suspension，**用一个线程等待另外一个线程的执行结果**

要点

+ 有一个结果需要从一个线程传递到另外一个线程，让他们关联同一个GuardedObject
+ 如果有结果不断从一个线程到另外一个线程，那么可以使用消息队列（生产者/消费者）
+ JDK中，join的实现，Future的实现，采用的就是这个模式
+ 因为要等待另一方的结果，因此归类到同步模式

![image-20200306084218855](D:\Desktop\面试\img\image-20200306084218855.png)

#### 3.6.2 实现

```java
class GuardedObject {
    private Object response;
    private final Object lock = new Object();
    
    // 获取结果
    public Object get() {
        synchronized(lock) {
            //条件不满足则等待
            while (response == null) {
                try{
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }
    
    // 返回结果
    publIc void complete(Object response) {
        synchronized(lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}
```

```java
public static void main(String[] args) {
	GuardedObject guardedObject = new GuardedObject();
	new Thread(() -> {
		try {
            // 子线程执行下载
            List<String> response = download();
            log.debug("download complete...");
            guardedObject.complete(response);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }).start();
    log.debug("waiting...");
    // 主线程阻塞等待
    Object response = guardedObject.get();
    log.debug("get response: [{}] lines", ((List<String>) response).size());
}
```

> 08:42:18.568 [main] c.TestGuardedObject - waiting...
> 08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...
> 08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines



#### 3.6.3 带超时版的 GuardedObject

```java
class GuardedObject {
    private Object response;
    private final Object lock = new Object();
    
    // 获取结果
    public Object get(long timeout) {
        synchronized(lock) {
            // 开始时间
            long begin = System.currentTimeMillis();
            // 记录经过的时间
            long timePassed = 0;
            // 等待时间
            long waitTime = timeout - timePassed;
            //条件不满足则等待
            while (response == null) {
                if (timePassed >= timeout) {
                    break;
                }
                try{
                    lock.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                timePassed = System.currentTimeMillis() - begin;
            }
            return response;
        }
    }
    
    // 返回结果
    publIc void complete(Object response) {
        synchronized(lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}
```

#### 3.6.4 join 原理

join的底层原理就是使用的**保护性暂停**设计模式

```java
public final synchronized void join(long millis) throws InterruptedException {
    // 开始时间
    long base = System.currentTimeMillis();
    // 经过的时间
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        // 就是保护式暂停中的带有超时的版本
        while (isAlive()) {
            // 等待时间
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}

public final void join() throws InterruptedException {
    join(0);
}
```

#### 3.6.5 多任务版 GuardedObject

![image-20200306105826937](D:\Desktop\面试\img\image-20200306105826937.png)

```java

```



### 3.7 ==(异步模式)模式：生成者/消费者==

#### 3.7.1 定义

要点

+ 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应
+ 消费队列可以用来平衡生产和消费的线程资源
+ 生产者进负责生产结果数据，不关心数据该如何处理，而消费者专心处理结果数据
+ 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
+ JDK中各种阻塞队列，采用的就是这种模式

![image-20200308124447626](D:\Desktop\面试\img\image-20200308124447626.png)

#### 3.7.2 实现

```java
class MessageQueue {
    // 消息队列集合
    private LinkedList<Message> list = new LinkedList<>();
    // 队列容量
    private int capcity;
    
    public MessageQueue(int capcity) {this.capcity = capcity;}
    
    // 获取消息
    public Message take() {
        // 检查队列是否为空
        synchronized (list) {
            while(list.isEmpty()) {
                try {
                    log.debug("没货了, wait");
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 从队列头部获取消息并返回
            Message message = list.removeFirst();
            log.debug("已消费消息 {}", message);
            list.notifyAll();
            return message;
        }
    }
    
    // 存入消息
    public void put(Message message) {
        synchronized (list) {
            // 检查对象是否已满
            while(list.size() == capcity) {
                try {
                    log.debug("库存已达上限, wait");
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 将消息加入队列尾部
            list.addLast(message);
            log.debug("已生产消息 {}", message);
            list.notifyAll();
        }
    }
}

final class Message {
    private int id;
    private Object value;
    
    public Message(int id, Object value) {
        this.id = id;
        this.value = value;
    }
    
    public int getId() {
        return id;
    }

    public Object getValue() {
        return value;
    }
    
    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", value=" + value +
                '}';
    } 
}
```

```java
public static void main(String[] args) {
    MessageQueue queue = new MessageQueue(2);

    for (int i = 0; i < 3; i++) {
        int id = i;
        new Thread(() -> {
            queue.put(new Message(id , "值"+id));
        }, "生产者" + i).start();
    }

    new Thread(() -> {
        while(true) {
            sleep(1);
            Message message = queue.take();
        }
    }, "消费者").start();
}
```



### 3.8 park & unpark

#### 3.8.1 基本使用

它们是 LockSupport 类中的方法

```java
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象)
```

##### 先 park 再 unpark

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
},"t1");
t1.start();
sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);
```

> 18:42:52.585 c.TestParkUnpark [t1] - start...
> 18:42:53.589 c.TestParkUnpark [t1] - park...
> 18:42:54.583 c.TestParkUnpark [main] - unpark...
> 18:42:54.583 c.TestParkUnpark [t1] - resume...

##### 先 unpark 再 park

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");
t1.start();
sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
```

> 18:43:50.765 c.TestParkUnpark [t1] - start...
> 18:43:51.764 c.TestParkUnpark [main] - unpark...
> 18:43:52.769 c.TestParkUnpark [t1] - park...
> 18:43:52.769 c.TestParkUnpark [t1] - resume...

#### 3.8.2 特点

与Object 的 wait& notify 相比

+ wait，notify 和 notifyAll 必须配合**Object Monitor** 一起使用，而park， upark不必
+ park&unpark 是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】
+ park&unpark 可以先 unpark，而wait&notify不能先notify

#### 3.8.3 原理

每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 

##### 先 park 再 unpark

+ 当前线程调用Unsafe.park()方法
+ 检查 _counter，本情况为0，这时获得 _mutex 互斥锁
+ 线程进入 _cond 条件变量阻塞
+ 设置 _counter = 0

![image-20200308134304486](D:\Desktop\面试\img\image-20200308134304486.png)

+ 调用Unsafe.unpark(Thread-0)方法，设置 _counter 为1
+ 唤醒 _cond 条件变量中的 Thread-0
+ Thread-0 恢复运行
+ 设置 _counter 为0

![image-20200308134044423](D:\Desktop\面试\img\image-20200308134044423.png)

##### 先 unpark 再 park

+ 调用Unsafe.unpark(Thread-0)方法，设置 _counter 为1
+ 当前线程调用 Unsafe.park()方法
+ 检查 _counter，本情况为1，这是线程无序阻塞，继续运行
+ 设置 _counter 为0

![image-20200308134754514](D:\Desktop\面试\img\image-20200308134754514.png)

### 3.9 重新理解线程状态转换

![image-20200308134935440](D:\Desktop\面试\img\image-20200308134935440.png)

假设有线程 Thread t

#### 情况1 NEW --> RUNNABLE

+ 当调用 t.start() 方法时，由  NEW --> RUNNABLE

#### 情况2 RUNNABLE <--> WAITING

t 线程用 synchronized(obj) 获取了对象锁后

+ 调用 obj.wait() 方法时候，t线程从RUNNABLE --> WAITING
+ 调用 obj.notify()，obj.notifyAll()，t.interrupt()时
  + 竞争锁成功，t 线程 WAITING --> RUNNABLE
  + 竞争锁失败，t 线程 WAITING --> BLOCKED

+ 当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING
  + 注意是 **当前线程** 在t线程对象的监视器上等待
+ t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE

#### 情况4 RUNNABLE <--> WAITING

+ 当前线程调用 LockSupport.park() 方法时，当前线程从 RUNNABLE --> WAITING
+ 调用 LockSupport.unpark(目标线程) 或调用了线程的 interrupt()，当前线程从 WAITING --> RUNNABLE

#### 情况5 RUNNABLE <--> TIMED_WAITING

t 线程用 synchronized(obj) 获取了对象锁后

+ 调用 obj.wait(long n) 方法时候，t线程从RUNNABLE --> WAITING
+ t 线程等待时间超过了 n 毫秒，或调用 obj.notify()，obj.notifyAll()，t.interrupt()时
  + 竞争锁成功，t 线程 WAITING --> RUNNABLE
  + 竞争锁失败，t 线程 WAITING --> BLOCKED

#### 情况6 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING
  + 注意是当前线程在t 线程对象的监视器上等待
+ 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从
  TIMED_WAITING --> RUNNABLE

#### 情况7 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
+ 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --> RUNNABLE

#### 情况8 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线
  程从 RUNNABLE --> TIMED_WAITING
+ 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从
  TIMED_WAITING--> RUNNABLE

#### 情况 9 RUNNABLE <--> BLOCKED

+ t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --> BLOCKED
+ 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然 BLOCKED

#### 情况 10 RUNNABLE <--> TERMINATED

当前线程所有代码运行完毕，进入TERMINATED



### 3.10 多把锁

#### 多把不相干的锁

一间大屋子有两个功能：睡觉、学习，互不相干。
现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低
解决方法是准备多个房间（多个对象锁）

例如

```java
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }
    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

执行

```java
BigRoom bigRoom = new BigRoom();
new Thread(() -> {
    bigRoom.compute();
},"小南").start();
new Thread(() -> {
    bigRoom.sleep();
},"小女").start();
```

某次结果

```java
12:13:54.471 [小南] c.BigRoom - study 1 小时
12:13:55.476 [小女] c.BigRoom - sleeping 2 小时
```

改进

```java
class BigRoom {
    private final Object studyRoom = new Object();
	private final Object bedRoom = new Object();
    public void sleep() {
        synchronized (studyRoom) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }
    public void study() {
        synchronized (bedRoom) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

某个执行结果

```java
12:15:35.069 [小南] c.BigRoom - study 1 小时
12:15:35.069 [小女] c.BigRoom - sleeping 2 小时
```

将锁的粒度细分

+ 好处：是可以增强并发度
+ 坏处：如果一个线程需要同时获得多把锁，就容易发生死锁

### 3.11 活跃性

#### 3.11.1 死锁

死锁：是指**两个或两个以上的进程（或线程）**在执行过程中，因**争夺资源而造成的一种互相等待的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁产生的条件

**死锁发生的条件**

- 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么**其他线程必须处于等待状态**，直到资源被释放。

- 请求和保持条件：线程T1**至少已经保持了一个资源R1占用**,但**又提出对另一个资源R2请求**，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但**又对自己保持的资源R1不释放**。

- 不剥夺条件：线程已获得的资源，**在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放**。

- 环路等待条件：在死锁发生时，**必然存在一个“进程-资源环形链”**，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）

```java
Object A = new Object();
Object B = new Object();
Thread t1 = new Thread(() -> {
    synchronized (A) {
        log.debug("lock A");
        sleep(1);
        synchronized (B) {
            log.debug("lock B");
            log.debug("操作...");
        }
    }
}, "t1");
Thread t2 = new Thread(() -> {
    synchronized (B) {
        log.debug("lock B");
        sleep(0.5);
        synchronized (A) {
            log.debug("lock A");
            log.debug("操作...");
        }
    }
}, "t2");
t1.start();
t2.start();
```

> 12:22:06.962 [t2] c.TestDeadLock - lock B
> 12:22:06.962 [t1] c.TestDeadLock - lock A

#### 3.11.2 定位死锁

+ 使用 jstack 定位死锁

```shell
jps
```

> 5840 Launcher
> 4312 RemoteMavenServer36
> 6328 TestDeadThread
> 12124
> 5516 Jps

```java
jstack 6328
```

> Found one Java-level deadlock:
>
> "t1":
>   waiting to lock monitor 0x000002857d191080 (object 0x0000000089aedcb8, a java.lang.Object),
>   which is held by "t2"
> "t2":
>   waiting to lock monitor 0x000002857d190f80 (object 0x0000000089aedca8, a java.lang.Object),
>   which is held by "t1"
>
> Java stack information for the threads listed above:
>
> "t1":
>         at TestDeadThread.lambda$main$0(TestDeadThread.java:15)
>         - waiting to lock <0x0000000089aedcb8> (a java.lang.Object)
>         - locked <0x0000000089aedca8> (a java.lang.Object)
>         at TestDeadThread$$Lambda$14/0x0000000100066840.run(Unknown Source)
>         at java.lang.Thread.run(java.base@11.0.1/Thread.java:834)
> "t2":
>         at TestDeadThread.lambda$main$1(TestDeadThread.java:30)
>         - waiting to lock <0x0000000089aedca8> (a java.lang.Object)
>         - locked <0x0000000089aedcb8> (a java.lang.Object)
>         at TestDeadThread$$Lambda$15/0x0000000100066c40.run(Unknown Source)
>         at java.lang.Thread.run(java.base@11.0.1/Thread.java:834)
>
> Found 1 deadlock.

+ 使用 jconsole 检测死锁

![image-20200308154550545](D:\Desktop\面试\img\image-20200308154550545.png)

![image-20200308154605879](D:\Desktop\面试\img\image-20200308154605879.png)



#### 3.11.3 哲学家就餐问题

```java
class Chopstick {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}	

class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }
    @Override
    public void run() {
        while (true) {
            // 获得左手筷子
            synchronized (left) {
                // 获得右手筷子
                synchronized (right) {
                    // 吃饭
                    eat();
                }
                // 放下右手筷子
            }
            // 放下左手筷子
        }
    }
}
```



#### 3.11.4 活锁

是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源

#### 3.11.5 饥饿

是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。



### 3.12 ReentrantLock

相对于 synchronized ，它具备如下特点

+ **可中断**（不会一直等待，等待可以被终止）
+ **可以设置超时时间**（等锁时间超过一定范围时，可自动释放锁资源）
+ **可以设置为公平锁**（资源竞争的公平，防止饥饿）
+ **支持多个条件变量**（sychronized 中，Monitor对象中的waitset，只要一个条件变量）

**与 synchronized 一样，都支持重入**

语法

```java
// 获取锁
reentrantLock.lock();
try {
    // 临界区
} finally {
    // 释放锁
    reentrantLock.unlock();
}
```

#### 3.12.1 可重入

可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，所以有权再次获取这把锁

如果是不可重入锁，那么第二次获得锁是，自己也会被锁挡住

```java
static ReentrantLock lock = new ReentrantLock();
public static void main(String[] args) {
    method1();
}
public static void method1() {
    lock.lock();
    try {
        log.debug("execute method1");
        method2();
    } finally {
        lock.unlock();
    }
}
public static void method2() {
    lock.lock();
    try {
        log.debug("execute method2");
        method3();
    } finally {
        lock.unlock();
    }
}
public static void method3() {
    lock.lock();
    try {
        log.debug("execute method3");
    } finally {
        lock.unlock();
    }
}
```

> 17:59:11.862 [main] c.TestReentrant - execute method1
> 17:59:11.865 [main] c.TestReentrant - execute method2
> 17:59:11.865 [main] c.TestReentrant - execute method3

#### 3.12.2 可打断

使用 Lock.lockInterruptibly() 可以打断正在等待锁的线程

线程在等待的过程中**被动的被打断**

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    try {
        // 可以打断的锁
        lock.lockInterruptibly();
    } catch (InterruptedException e) {
        e.printStackTrace();
        log.debug("等锁的过程中被打断");
        return;
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(1);
    t1.interrupt();
    log.debug("执行打断");
} finally {
    lock.unlock();
}
```

> 18:02:40.520 [main] c.TestInterrupt - 获得了锁
> 18:02:40.524 [t1] c.TestInterrupt - 启动...
> 18:02:41.530 [main] c.TestInterrupt - 执行打断
> java.lang.InterruptedException
> at
> java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr
> onizer.java:898)
> at
> java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron
> izer.java:1222)
> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)
> at java.lang.Thread.run(Thread.java:748)
> 18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断

#### 3.12.3 锁超时

如果无法获得锁,则主动放弃竞争,使用 lock.tryLock()

##### 立刻失败

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    if (!lock.tryLock()) {
        log.debug("获取立刻失败，返回");
        return;
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(2);
} finally {
    lock.unlock();
}
```

> 18:15:02.918 [main] c.TestTimeout - 获得了锁
> 18:15:02.921 [t1] c.TestTimeout - 启动...
> 18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回

##### **超时失败**

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    try {
        if (!lock.tryLock(1, TimeUnit.SECONDS)) {
            log.debug("获取等待 1s 后失败，返回");
            return;
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(2);
} finally {
    lock.unlock();
}
```

> 18:19:40.537 [main] c.TestTimeout - 获得了锁
> 18:19:40.544 [t1] c.TestTimeout - 启动...
> 18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回

##### 可以解决哲学家就餐问题

```java
class Chopstick extends ReentrantLock {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
```

```java
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            // 尝试获得左手筷子
            if (left.tryLock()) {
                try {
                    // 尝试获得右手筷子
                    if (right.tryLock()) {
                        try {
                            eat();
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock();
                }
            }
        }
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }
}
```

#### 3.12.4 公平锁



#### 3.12.5 条件变量

synchronized 中也有条件变量，就是我们讲原理是那个 waitset休息室，当条件不满足是进入 waitset休息室中等待

ReentrantLock 的条件变量比 synchronized 强大之处在于，他是支持多个变量条件的，就好比

+ synchronized 是那些不满足条件的线程都在一间休息室等消息
+ 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

**使用要点**

+ await 前要获得锁
+ await 执行后，会释放锁，进入 conditionObject 等待
+ await 的线程被唤醒（或打断，或超时）去重新竞争lock锁
+ 竞争 lock 锁成功后，从 await 后继续执行

```java
static ReentrantLock lock = new ReentrantLock();
static Condition waitCigaretteQueue = lock.newCondition();
static Condition waitbreakfastQueue = lock.newCondition();
static volatile boolean hasCigrette = false;
static volatile boolean hasBreakfast = false;
public static void main(String[] args) {
    new Thread(() -> {
        try {
            lock.lock();
            while (!hasCigrette) {
                try {
                    waitCigaretteQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("等到了它的烟");
        } finally {
            lock.unlock();
        }
    }).start();
    new Thread(() -> {
        try {
            lock.lock();
            while (!hasBreakfast) {
                try {
                    waitbreakfastQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("等到了它的早餐");
        } finally {
            lock.unlock();
        }
    }).start();
    sleep(1);
    sendBreakfast();
    sleep(1);
    sendCigarette();
}
private static void sendCigarette() {
    lock.lock();
    try {
        log.debug("送烟来了");
        hasCigrette = true;
        waitCigaretteQueue.signal();
    } finally {
        lock.unlock();
    }
}
private static void sendBreakfast() {
    lock.lock();
    try {
        log.debug("送早餐来了");
        hasBreakfast = true;
        waitbreakfastQueue.signal();
    } finally {
        lock.unlock();
    }
}
```

> 18:52:27.680 [main] c.TestCondition - 送早餐来了
> 18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐
> 18:52:28.683 [main] c.TestCondition - 送烟来了
> 18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟



### 3.13 ==(同步模式)模式：顺序控制==

#### 3.13.1 固定运行顺序

##### 1. wait&notify 版

```java
public class RunByOrder {
    static final Object lock = new Object();
    static boolean t2Runned = false;

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                while (!t2Runned) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t1: 1");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("t2: 2");
                t2Runned = true;
                lock.notify();
            }
        });

        t1.start();
        t2.start();

    }
}
```

##### 2. ReentrantLock

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class RunByOrder {
    static final ReentrantLock lock = new ReentrantLock();
    static final Condition waitSet = lock.newCondition();
    static boolean t2Runned = false;

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            lock.lock();
            try{
                while (!t2Runned) {
                    try {
                        waitSet.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t1: 1");
            } finally {
                lock.unlock();
            }
        });

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("t2: 2");
                t2Runned = true;
                waitSet.signal();
            } finally {
                lock.unlock();
            }
        });

        t1.start();
        t2.start();

    }
}
```

##### 3. park & unpark 版

+ 使用park&unpark简化该过程
+ 无论哪个线程先访问，都无所谓，并且是以线程单位暂停和恢复的，所以不需要同步对象和运行标记

```java
import java.util.concurrent.locks.LockSupport;

public class RunByOrder2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            LockSupport.park();
            System.out.println("t1 : 1");
        });
        t1.start();

        new Thread(() -> {
            System.out.println("t2 : 2");
            LockSupport.unpark(t1);
        }, "t2").start();
    }
}
```



#### 3.13.2 交替输出

##### 1. wait&notify版本

```java
public class RunByTurn {
    public static void main(String[] args) {
        WaitNotify wn = new WaitNotify(1, 5);
        new Thread(() -> {
            wn.print("a", 1, 2);
        },"t1").start();
        new Thread(() -> {
            wn.print("b", 2, 3);
        },"t2").start();
        new Thread(() -> {
            wn.print("c", 3, 1);
        },"t3").start();
    }
}

class WaitNotify {
    // 等待标记位
    private int flag;
    // 循环次数
    private int loopNumber;

    public WaitNotify(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }

    public void print(String str, int waitFlag, int nextFlag){
        for (int i = 0; i < loopNumber; i++) {
            synchronized (this) {
                while (waitFlag != flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }
}

```

> abcabcabcabcabc



##### 2. ReentrantLock

+ 有多个休息室，我们可以将不同的线程放入不同的休息室中

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class RunByTurn2 {
    public static void main(String[] args) throws InterruptedException {
        AwaitSignal as = new AwaitSignal(5);
        Condition a = as.newCondition();
        Condition b = as.newCondition();
        Condition c = as.newCondition();

        new Thread(() -> {
            as.print("a", a, b);
        },"t1").start();
        new Thread(() -> {
            as.print("b", b, c);
        },"t2").start();
        new Thread(() -> {
            as.print("c", c, a);
        },"t3").start();

        Thread.sleep(1000);
        as.lock();
        try {
            a.signal();
        } finally {
            as.unlock();
        }
    }
}

class AwaitSignal extends ReentrantLock {
    // 循环次数
    private int loopNumber;

    public AwaitSignal(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    // 打印             参数1 打印内容, 参数2 本休息室， 参数3 唤醒的休息室
    public void print(String str, Condition current, Condition next) {
        for (int i = 0; i < loopNumber; i++) {
            lock();
            try {
                current.await();
                System.out.print(str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }
}

```



##### 3. park&unpark

```java
import java.util.concurrent.locks.LockSupport;

public class RunByTurn3 {
    static Thread t1;
    static Thread t2;
    static Thread t3;

    public static void main(String[] args) {
        ParkUnpark pup = new ParkUnpark(5);
        t1 = new Thread(() -> {
            pup.print("a", t2);
        });
        t2 = new Thread(() -> {
            pup.print("b", t3);
        });
        t3 = new Thread(() -> {
            pup.print("c", t1);
        });


        t1.start();
        t2.start();
        t3.start();

        LockSupport.unpark(t1);
    }
}

class ParkUnpark {
    // 循环次数
    private int loopNumber;

    public ParkUnpark(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    public void print(String str, Thread next) {
        for (int i = 0; i < loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
}

```



### 本章小结

+ 分析多线程访问共享资源时，哪些代码片段属于临界区
+ 使用 **synchronized** 互斥解决临界区的线程安全问题
  + 掌握 synchronized 锁对象语法
  + 掌握 synchronzied 加载成员方法和静态方法语法
  + 掌握 wait/notify 同步方法
+ 使用 **lock** 互斥解决临界区的线程安全问题
  + 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量
+ 学会分析变量的线程安全性、掌握**常见线程安全类**的使用
+ 了解线程活跃性问题：死锁、活锁、饥饿
+ ==应用方面==
  + 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果
  + 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果
+ ==原理方面==
  + monitor、synchronized 、wait/notify 原理
  + synchronized 进阶原理
  + park & unpark 原理
+ ==模式方面==
  + 同步模式之保护性暂停
  + 异步模式之生产者消费者
  + 同步模式之顺序控制



## 4. 共享模型之内存

### 4.1 Java 内存模型

JMM 即 Java Memory Model，它定义了**主存、工作内存**抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等

JMM 体现在以下几个方面

+ **原子性** - 保证指令不会受到**线程上下文切换**的影响
+ **可见性** - 保证指令不会受 **CPU 缓存**的影响
+ **有序性** - 保证指令不会受 **cpu 指令并行优化**的影响



### 4.2 可见性

#### 4.2.1 例子：退不出的循环

```java
static boolean run = true;

public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while (true) {
            //...
        }
    });
    t.start();

    Thread.sleep(1);
    System.out.print("开始");
    run = false;
}
```

> 线程t无法退出循环

##### 原因分析：

+ 初始状态，t线程刚开始从主内存中读取了 run 的值到工作内存

![image-20200309205333232](D:\Desktop\面试\img\image-20200309205333232.png)

+ 因为 t 线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存到自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率

![image-20200309205818395](D:\Desktop\面试\img\image-20200309205818395.png)

+ 1s 之后，main线程修改了run的值，并同步到主存中，为t是从自己的工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![image-20200309205936445](D:\Desktop\面试\img\image-20200309205936445.png)

##### 解决办法

使用 volatile （易变关键字）

他可以用来修饰成员变量和静态成员变量，可以避免从自己的工作缓存中查找变量的值，必须到主存中获取他的值，线程操作volatile 变量都是直接操作主存

#### 4.2.2 ==(终止模式)模式：两阶段终止==

```java
class TPTInterrupt {
    private Thread thread;
    private volatile boolean stop = false;
    
    public void start() {
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (stop) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}
```

#### 4.2.3 ==(同步模式) balking==

##### 定义

Balking（犹豫）模式用在一个线程发现另外一个线程或本县城已经做了某一件相同的事，那么本线程就无需再做了

##### 实现

```java
class TPTInterrupt {
    private Thread thread;
    private volatile boolean stop = false;
    private volatile boolean starting = false;
    
    public void start() {
        // 需要加锁来保证互斥，不会被多个线程同时修改
        synchronized(this) {
            if (starting) {
                return;
            }
            starting = true;
        }
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (stop) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}
```



### 4.3 有序性

### 4.4 volatile原理-双重检验单例模式

```java
public final class Singleton {
    private Singleton(){}
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                // 这个判断是为了第一次创建对象时，如果有一个线程进入还未创建完时，另一个线程也进入，假设这时第一个线程已经创建好对象，则第二个线程就无序再创建对象
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

+ 其中，synchronized 用来互斥
+ volatile 关键字用来防止指令重排
  + instance = new Singleton();
  + 1-创建对象
  + 2-初始化
  + 3-将对象赋值给变量引用
  + 在优化指令重排中，可能导致先执行3，后执行2，导致在这两条指令之间来的进程误以为对象已经创建完成，而直接返回导致错误。



```java
// 内部类实现单例模式
public final class Singleton {
    private Singleton(){}
    private static class LazyOut{
        private final static Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance(){
        return LazyOut.INSTANCE;
    }
}
```



