并发编程

## 1. 进程与线程

### 1.1 进程与线程

+ 进程
  + 程序是由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至cpu，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存，管理IO的
  + 当一个程序被运行，从磁盘加载这个程序的代码至内存，这是就开启了一个进程
  + 进程就可以视为程序的一个实例，大部分程序可以同时运行多个实例进程
+ 线程
  + 一个进程之内可以分为一到多个线程
  + 一个线程就是一个指令流，将指令流中 一条条指令以一定的顺序交给CPU执行
  + java中，线程是最小的调度单位，进程是资源分配的最小单位
+ 区别
  + 进程基本上是独立的，而线程存在于进程之中，是进程的一个子集
  + 进程拥有共享资源，如内存空间等，供其内部线程使用
  + 进程之间的通讯较为复杂
    + 同一台计算机的进程通信称为IPC
    + 不同计算机之间的进程通讯，需要通过网路，并遵守共同的协议，如HTTP
  + 线程的通讯较为简单，因为他们是共享进程内的内存，多个线程可以访问同一个共享变量
  + 线程的上下文切换成本一般比进程的低

### 1.2 并行与并发

+ 单核cpu
  + 线程实际上串行执行的，微观串行，宏观并行
  + **线程轮流使用cpu的做法称为并**发，concurrent
+ 多核cpu
  + 每个core都可以调度运行线程，线程是并行的，parallel

### 1.3 ==(效率)应用==

#### 异步调用

以调用方角度来看

+ 需要等待结果返回，才能继续运行的就是同步
+ 不需要等待结果返回，就能继续运行就是异步

#### 提高效率

+ 单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活
+ 多核cpu可以并行跑多个线程，但能否程序运行效率还是要分情况的
  + 有些任务，能有拆分，可以提高运行效率，但是并不是所有任务都可以拆分的（阿姆达尔定律）
  + 也不是所有的任务都需要拆分
+ IO操作不占用cpu，只是我们一般拷贝文件使用的是阻塞IO，这是相当于线程虽然不用cpu，但需要一直等待IO结束，没有充分利用线程，所有才有了非阻塞IO和异步IO优化



## 2. Java线程

> + 创建和运行线程
> + 查看线程
> + 线程API
> + 线程状态

### 2.1 创建和运行线程

#### 方法一：直接使用 Thread

```java
// 创建线程对象
Thread t = new Thread() {
	public void run() {
	// 要执行的任务
	}
};
// 启动线程
t.start();
```

```java
// 构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread("t1") {
	@Override
	// run 方法内实现了要执行的任务
	public void run() {
		log.debug("hello");
	}
};
t1.start();
```

> 19:19:00 [t1] c.ThreadStarter - hello

#### 方法二：使用Runnable 配合 Thread

把【线程】和【任务】（要执行的代码）分开

+ Thread 代表线程
+ Runnable 可运行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable() {
	public void run(){
	// 要执行的任务
	}
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

```java
// 创建任务对象
Runnable task2 = new Runnable() {
	@Override
	public void run() {
		log.debug("hello");
	}
};

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

> 19:19:00 [t2] c.ThreadStarter - hello

```java
// 创建任务对象
Runnable task2 = () -> log.debug("hello");

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

#### Thread 和 Runnable 的关系

+ 源码

  + thread类实现了runnable接口，重写run方法，将runnable 对象传入 Thread 构造函数中，会赋值给Thread中的一个target对象，当thread执行run方法时，会判断这个target是否为空，不为空，则执行该对象的run方法

  ```java
  private Runnable target;
  // 这个target是外部传来的 runnable 对象
  this.target = target;
  
  public void run() {
      if (target != null) {
          target.run();
      }
  }
  ```

+ 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了
+ 用Runnable 更容易与线程池等高级 API 配合
+ 用Runnable 让任务类脱离了 Thread 继承体系，更灵活

#### 方法三：FutureTask 配合 Thread

FutureTask 能够接收 Callable 类型的参数，用来处理**有返回结果**的情况

```java
// 创建任务对象
FutureTask<Integer> task3 = new FutureTask<>(() -> {
	log.debug("hello");
	return 100;
});
// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, "t3").start();
// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
log.debug("结果是:{}", result);
```

> 19:22:27 [t3] c.ThreadStarter - hello
> 19:22:27 [main] c.ThreadStarter - 结果是:100

+ 源码
  + FutureTask 实现了一个 RunnableFuture 接口
  + RunnableFuture 接口 实现了 Runnable、Future接口
  + Future接口提供一个get方法来返回结果
  + FutureTask 结合一个 Callable 接口，callable 接口有一个call方法来实现返回结果
  + FutureTask 接收一个 Callable 对象，用户重写了call 方法（有返回值），FutureTask重写了 run方法，中间调用了call方法，call方法将结果复制给一个outcome变量，用于后续的获取。Thread 依旧会将FutureTask(继承了Runnable类) 赋值给 target，然后调用了run，调用了call
  + FutureTask 提供了 get 方法来获取到 call 的返回值。

### 2.3 查看进程线程的方法

+ windows
  + 任务管理器可以查看进程和线程数，也可以用来杀死进程
  + tasklist 查看进程
  + taskkill 杀死进程
+ linux
  + ps -fe 查看所有进程
  + ps -fT -p <PID> 查看某个进程（PID）的所有线程
  + kill 杀死进程
  + top 按大写 H 切换是否显示线程
  + top -H -p <PID> 查看某个进程（PID）的所有线程
+ Java
  + jps 命令查看所有 Java 进程
  + jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
  + jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

### 2.4 ==原理之线程运行==

#### 栈与栈帧

java虚拟机栈，线程私有，是描述 **Java 方法执行的内存模型**，每个方法在执行的同时都会创建一个**栈帧（**Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

#### 线程上下文切换（Thread Context Switch）

cpu不再执行当前的线程，而执行另一个线程的代码

+ 线程的cpu时间片用完
+ **垃圾回收**
+ 有更高优先级的线程需要运行
+ 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法

### 2.5. 常见方法

#### 2.5.1 start 和 run

**调用run方法**

```java
public static void main(String[] args) {
	Thread t1 = new Thread("t1") {
		@Override
		public void run() {
		log.debug(Thread.currentThread().getName());
		FileReader.read(Constants.MP4_FULL_PATH);
		}
	};
	t1.run();
	log.debug("do other things ...");
}
```

> 19:39:14 [main] c.TestStart - main
> 19:39:14 [main] c.FileReader - read [1.mp4] start ...
> 19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms
> 19:39:18 [main] c.TestStart - do other things ...

程序仍在 main 线程运行，FileReader.read() 方法调用还是同步的

**调用strat**

```java
// 将上述代码的t1.run() 改为
t1.start();
```

> 19:41:30 [main] c.TestStart - do other things ...
> 19:41:30 [t1] c.TestStart - t1
> 19:41:30 [t1] c.FileReader - read [1.mp4] start ...
> 19:41:35 [t1] c.FileReader - read [1.mp4] end ... cost: 4542 ms

程序在 t1 线程运行， FileReader.read() 方法调用是异步的

**小结**

+ 直接调用run是在主线程中执行run，没有启动新的线程
+ 使用start是启动新的线程，通过新的线程间接执行了run中的代码

#### 2.5.2 sleep 和 yield

**sleep**

+ 调用sleep会让当前线程从 **Running 进入 Timed Wating 状态（阻塞）**
+ 其他线程可以使用 interrupt 方法打断正在睡眠的线程，这是 sleep 方法会抛出 `InterruptedException` ，会清除打断标记
+ 睡眠结束后的线程未必会立刻得到执行（要看任务调度器是否分到时间片给这个线程）
+ 建议使用 TimeUnit 的sleep 代替 Thread 的sleep 来获得更好的可读性

**yield**

+ 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其他线程
+ 但是具体的实现依赖于操作系统的任务调度器（也即线程未必能够成功的让出cpu）

**线程优先级**

+ 线程优先级会**提示**调度器优先调度该线程，但是它仅仅只是一个提示，调度器可以忽略它
+ 如果cpu较忙，name优先级较高的线程会获得更多的时间片，但是如果cpu闲时，优先级几乎没作用

##### ==(限制)应用：利用sleep来限制cpu的使用==

在没有利用cpu来计算是，不要让 while（true）空转浪费 cpu，这时可以使用yield 或 sleep 来让出cpu的使用权给其他进程

```java
while(true) {
	try {
		Thread.sleep(50);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
}
```

#### 2.5.3 join

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待 n 毫秒

##### ==(同步)应用：应用之同步==

以调用方角度来讲，如果

+ 需要等待结果返回，才能继续运行就是同步
+ 不需要等待结果返回，就能继续运行就是异步

```java
static int r = 0;
public static void main(String[] args) throws InterruptedException {
	test1();
}
private static void test1() throws InterruptedException {
	log.debug("开始");
	Thread t1 = new Thread(() -> {
		log.debug("开始");
		sleep(1);
		log.debug("结束");
		r = 10;
	});
	t1.start();
    t1.join();
	log.debug("结果为:{}", r);
	log.debug("结束");
}
```

![image-20200302214843282](D:\Desktop\面试\img\image-20200302214843282.png)

**等待多个结果**

问，下面代码 cost 大约多少秒？

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test2();
}
private static void test2() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	Thread t2 = new Thread(() -> {
		sleep(2);
		r2 = 20;
    });
	long start = System.currentTimeMillis();
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005

分析

+ 第一个 join：等待 t1时，t2并没有停止，而在运行
+ 第二个 join：1s后，执行到此，t2也运行了1s，因此也只需要等待1s
+ 如果颠倒两个join，结果也是一样的

![image-20200302215503406](D:\Desktop\面试\img\image-20200302215503406.png)

##### 有时效的join

等够时间

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test3();
}
public static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(1);
		r1 = 10;
	});
	long start = System.currentTimeMillis();
	t1.start();
    // 线程执行结束会导致 join 结束
	t1.join(1500);
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:48:01.320 [main] c.TestJoin - r1: 10 r2: 0 cost: 1010

没等够时间

```java
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
	test3();
}
public static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		sleep(2);
		r1 = 10;
	});
	long start = System.currentTimeMillis();
	t1.start();
    // 线程执行结束会导致 join 结束
	t1.join(1500);
	long end = System.currentTimeMillis();
	log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```

> 20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502

#### 2.5.4 interrupt()

##### 打断 sleep、wait、join的线程

这几个方法都会让线程进入阻塞状态

打断 sleep 的线程，会清空打断状态，以sleep为例

```java
private static void test1() throws InterruptedException {
	Thread t1 = new Thread(()->{
		sleep(1);
	}, "t1");
	t1.start();
	sleep(0.5);
	t1.interrupt();
	log.debug(" 打断状态: {}", t1.isInterrupted());
}
```

> java.lang.InterruptedException: sleep interrupted
> at java.lang.Thread.sleep(Native Method)
> at java.lang.Thread.sleep(Thread.java:340)
> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
> at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
> at java.lang.Thread.run(Thread.java:745)
> 21:18:10.374 [main] c.TestInterrupt - **打断状态: false**

##### 打断正常运行的线程

打断正常运行的线程，不会清空打断状态

```java
private static void test2() throws InterruptedException {
	Thread t2 = new Thread(()->{
        while(true) {
            Thread current = Thread.currentThread();
            boolean interrupted = current.isInterrupted();
            if(interrupted) {
                log.debug(" 打断状态: {}", interrupted);
                break;
            }
		}
	}, "t2");
	t2.start();
	sleep(0.5);
	t2.interrupt();
}
```

> 20:57:37.964 [t2] c.TestInterrupt - **打断状态: true**

可以使用 isInterrupt() 方法来获取线程的打断状态

##### ==(终止模式)模式：两阶段终止模式==

在一个线程T1中如何【优雅】终止线程T2，这里的【优雅】是指给T2一个料理后事的机会

**1. 错误的思路**

+ 使用线程对象的 stop() 方法停止线程
  + stop方法会真正杀死线程，如果这是线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程将永远无法获得锁
+ 使用 System,exit(init) 方法
  + 目的仅是停止一个线程，但这种作法会让整个程序都停止

**2. 两阶段停止模式**

![image-20200302223920128](D:\Desktop\面试\img\image-20200302223920128.png)

**2.1 利用interrupt**

interrupt可以打断正在执行的线程，无论这个线程是在sleep、wait，还是正常运行

```java
class TPTInterrupt {
    private Thread thread;
    
    public void start() {
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (current.isInterrupted()) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                    // 当打断sleep时，打断标记会被清除，导致由重新进行监控，所以在捕捉到打断异常时，需要再次打断，来获取打断标记
                    current.interrupt();
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        thread.interrupt();
    }
}
```

调用

```java
TPTInterrupt t = new TPTInterrupt();
t.start();
Thread.sleep(3500);
log.debug("stop");
t.stop();
```

##### 打断 park 线程

打断park线程，不会清空打断状态

```java
private static void test3() throws InterruptedException {
	Thread t1 = new Thread(() -> {
		log.debug("park...");
		LockSupport.park();
		log.debug("unpark...");
		log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
	}, "t1");
	t1.start();
	sleep(0.5);
	t1.interrupt();
}
```

> 21:11:52.795 [t1] c.TestInterrupt - park...
> 21:11:53.295 [t1] c.TestInterrupt - unpark...
> 21:11:53.295 [t1] c.TestInterrupt - 打断状态：true

如果打断标记为true，则park会失效

```java
private static void test4() {
	Thread t1 = new Thread(() -> {
		for (int i = 0; i < 5; i++) {
			log.debug("park...");
			LockSupport.park();
			log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
		}
	});
	t1.start();
	sleep(1);
	t1.interrupt();
}
```

> 21:13:48.783 [Thread-0] c.TestInterrupt - park...
> 21:13:49.809 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.812 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
> 21:13:49.813 [Thread-0] c.TestInterrupt - park...
> 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true

**可以使用 Thread.interrupted 来清除打断标记，与 isInterrupted 都是可以获取打断标志位，不同的是，前者会清除标记位，后者不会清除标记位，按需使用**

### 2.6 守护线程

默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束

```java
log.debug("开始运行...");
Thread t1 = new Thread(() -> {
	log.debug("开始运行...");
	sleep(2);
	log.debug("运行结束...");
	}, "daemon");
// 设置该线程为守护线程
t1.setDaemon(true);
t1.start();
sleep(1);
log.debug("运行结束...");
```

> 08:26:38.123 [main] c.TestDaemon - 开始运行...
> 08:26:38.213 [daemon] c.TestDaemon - 开始运行...
> 08:26:39.215 [main] c.TestDaemon - 运行结束...

**注意**

+ 垃圾回收器线程就是一种守护线程

### 2.7 线程状态

#### 2.7.1 五种状态

在操作系统层面来描述

![image-20200302233901360](D:\Desktop\面试\img\image-20200302233901360.png)

+ 初始状态：仅是在语言层面创建了线程对象，还未与操作系统线程关联
+ 可运行状态：（就绪状态）指该程序已经被创建（与操作系统线程关联），可以由CPU调度执行
+ 运行状态：获取了CPU时间片运行中的状态
  + 当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换
+ 阻塞状态：
  + 如果调用了阻塞API，如IO读写文件，这是该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态
  + 等IO操作结束时，会由操作系统唤醒阻塞的线程，转换至可运行状态
  + 与可运行状态的区别是，对阻塞状态的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们
+ 终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态

#### 2.7.2 六种状态

这是从 Java API 层面来描述的

根据 Thread.State 枚举，分为六种状态

![image-20200302234759344](D:\Desktop\面试\img\image-20200302234759344.png)

+ `NEW`：线程刚被创建，还没有调用 `start()` 方法
+ `RUNNABLE`：当调用 `start()` 方法之后，注意，Java API 层面 的 `RUNNABLE` 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】
+ `BLOCKED` ， `WAITING` ， `TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述
+ `TERMINATED` 当线程代码运行结束

### 2.8 ==(统筹)应用：烧水泡茶==

```java
Thread t1 = new Thread(() -> {
	log.debug("洗水壶");
	sleep(1);
	log.debug("烧开水");
	sleep(15);
}, "老王");

Thread t2 = new Thread(() -> {
	log.debug("洗茶壶");
	sleep(1);
	log.debug("洗茶杯");
	sleep(2);
	log.debug("拿茶叶");
	sleep(1);
	try {
		t1.join();
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	log.debug("泡茶");
}, "小王");

t1.start();
t2.start();
```

> 19:19:37.547 [小王] c.TestMakeTea - 洗茶壶
> 19:19:37.547 [老王] c.TestMakeTea - 洗水壶
> 19:19:38.552 [小王] c.TestMakeTea - 洗茶杯
> 19:19:38.552 [老王] c.TestMakeTea - 烧开水
> 19:19:40.553 [小王] c.TestMakeTea - 拿茶叶
> 19:19:53.553 [小王] c.TestMakeTea - 泡茶

+ 上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶呢？代码最好能适应两种情况
+ 上面的两个线程其实是各执行各的，如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡茶呢

### 本章小结

+ 线程的创建
  + thread，runnable，futureTask
+ 线程重要api，start、run、sleep、join、interrupt
+ 线程状态
+ 应用方面
  + 异步调用：主线程执行期间，其他线程异步执行
  + 提高效率：并行计算，缩短运算时间
  + 同步等待：join
  + 统筹规划：合理使用线程，得到最优效果
+ 原理方面
  + 线程运行流程：栈、栈帧、上下文切换、程序计数器
  + Thread两种创建方式的源码
+ 模式方面
  + 终止模式之两阶段终止



## 3.共享模型之管程

> + 共享问题
> + synchronized
> + 线程安全分析
> + Monitor
> + wait/notify
> + 线程状态转换
> + 活跃性
> + Lock

### 3.1 共享问题

java程序是由指令和数据组成的，一条java代码，在底层可能不是一个原子操作，同时cpu采用分时系统，会导致线程之间的上下文切换，这时就可能导致一个共享资源的数据不一致性问题

#### 临界区

+ 一个程序运行多个线程本身是没有问题的
+ 问题出在多个线程访问**共享资源**
  + 多个线程读共享资源其实也没有问题
  + 在多个线程对共享资源读写操作是发生**指令交错**，就会出现问题。
+ **一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区**

#### 竞态条件

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称为发生了竞态条件

### 3.2 sychronized解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的

+ 阻塞式的解决方案：synchronized，Lock
+ 非阻塞式的解决方案：原子变量



sychronized，俗称【对象锁】，他采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其他线程再想获取这个【对象锁】时就会被阻塞。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

> 注：
>
> 虽然java中互斥和同步都可以采用sychronized关键字来完成，但是它们还是有区别的
>
> + **互斥**是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
> + **同步**是由于线程执行的先后、顺序不同、需要一个线程等待其他线程运行到某个点（协作）

语法：

```java
synchronized(对象) {// 线程1， 线程2(blocked)
	临界区
}
```

**思考**

+ **synchronized 实际是用==对象锁==保证了==临界区内代码的原子性==**，临界区内的代码对外是不可分割的，不会被线程切换所打断。

**锁对象**

```java
public static sychronized void fun(){
    // 锁住的是Class对象
} 
public sychronized void fun(){
    // 锁住的是this对象
} 
public void fun(){
    sychronized(obj) {
        // 锁住obj对象
    }
}
```



### 3.3 变量的线程安全性分析

#### 3.3.1 成员变量和静态变量是否线程安全？

+ 如果他们没有共享，则线程安全
+ 如果他们被共享了，根据他们的状态是否能够改变，有分为两种情况
  + 如果只是读操作，则线程安全
  + 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 3.3.2 局部变量是够线程安全？

+ 局部变量是线程安全的
+ 但是局部变量引用的对象则未必
  +  如果这个对象没有逃离方法的作用范围，他是线程安全的
  + 如果该对象逃离方法的作用范围，需要考虑线程安全

#### 3.3.3 局部变量线程安全分析

##### 局部变量是线程安全的

```java
public static void test1() {
	int i = 10;
	i++;
}
```

每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享.

![image-20200304153505585](D:\Desktop\面试\img\image-20200304153505585.png)

##### **局部变量的引用稍有不同**

先看一个成员变量的例子

```java
class ThreadUnsafe {
	ArrayList<String> list = new ArrayList<>();
	public void method1(int loopNumber) {
		for (int i = 0; i < loopNumber; i++) {
		// { 临界区, 会产生竞态条件
			method2();
			method3();
            // } 临界区
		}
	}
	private void method2() {
		list.add("1");
	}
	private void method3() {
		list.remove(0);
	}
}
```

执行

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
	ThreadUnsafe test = new ThreadUnsafe();
	for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：

> Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
> at java.util.ArrayList.rangeCheck(ArrayList.java:657)
> at java.util.ArrayList.remove(ArrayList.java:496)
> at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35)
> at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26)
> at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14)
> at java.lang.Thread.run(Thread.java:748)

分析：

+ 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量
+ method3 与 method2 分析相同

![image-20200304161335483](D:\Desktop\面试\img\image-20200304161335483.png)

**将list修改为局部变量**

```java
final class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
    	list.add("1");
    }
    private void method3(ArrayList<String> list) {
    	list.remove(0);
    }
}
```

那么就不会有上述问题了

分析：

+ list 是局部变量，每个线程调用时会创建其不同实例，没有共享
+ 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象
+ method3 的参数分析与 method2 相同

![image-20200304161609436](D:\Desktop\面试\img\image-20200304161609436.png)

方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 **public** 会不会代理线程安全问题？

+ 情况1：有其它线程调用 method2 和 method3
+ 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即

```java
class ThreadSafe {
	public final void method1(int loopNumber) {
		ArrayList<String> list = new ArrayList<>();
		for (int i = 0; i < loopNumber; i++) {
			method2(list);
			method3(list);
		}
	}
    
	public void method2(ArrayList<String> list) {
		list.add("1");
    }
    public void method3(ArrayList<String> list) {
    	list.remove(0);
    }
}

class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```



>  从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】



### 3.4 Monitor概念

#### 3.4.1 Java 对象头

Java 对象

+ 对象头
  + markword
  + klass word
    + 指向类的指针
+ 实例数据
+ 对齐填充字节

普通对象

![image-20200305215133520](D:\Desktop\面试\img\image-20200305215133520.png)

数组对象

![image-20200305215201677](D:\Desktop\面试\img\image-20200305215201677.png)

其中markword 结构为（64位）

![image-20200305215241575](D:\Desktop\面试\img\image-20200305215241575.png)



#### 3.4.2 Monitor 原理

Monitor -  管程 -  监视器

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁之后，该对象中的Mark Word 中就被设置指向 Monitor 对象的指针

![image-20200305215558821](D:\Desktop\面试\img\image-20200305215558821.png)

+ 刚开始的 Monitor 中的 Owner 为 null
+ 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一
  个 Owner
+ 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入
  EntryList BLOCKED
+ Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的
+ 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析

> 注意：
>
> + synchronized 必须是进入同一个对象的 monitor 才有上述的效果
> + 不加 synchronized 的对象不会关联监视器，不遵从以上规则

#### 3.4.3  synchronized 原理进阶

##### 1. 轻量级锁

轻量级锁的**使用场景**：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化

轻量级锁对使用者是透明的，即语法仍是 sychronized

假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
    	// 同步块 A
    	method2();
    }
}
public static void method2() {
    synchronized( obj ) {
    	// 同步块 B
    }
}
```

+ **创建锁记录（Lock Record）对象**，每个线程的栈帧都会包含一个锁对象的结构，内部可以存储锁对象的 Mark Word

  ![image-20200305222119612](D:\Desktop\面试\img\image-20200305222119612.png)

+ 让锁记录中 Object reference 指向锁对象，并尝试用 **cas**（保证线程之间的安全性） 替换 object 的 mark word，将 mark word 的值存入锁记录

  ![image-20200305222749774](D:\Desktop\面试\img\image-20200305222749774.png)

+ 如果 **cas 替换成功**，对象头中存储了 **锁记录地址和状态 00 **，表示由该线程给对象加锁

  ![image-20200305222849667](D:\Desktop\面试\img\image-20200305222849667.png)

+ 如果 **cas 替换失败**，有两种情况

  + 如果是其他线程已经持有了该 Object 的轻量级锁，这是表明有竞争，进入锁膨胀过程
  + 如果是自己执行了synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

  ![image-20200305223158073](D:\Desktop\面试\img\image-20200305223158073.png)

+ 当退出 sychronized 代码块（解锁时），如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

  ![image-20200305223323979](D:\Desktop\面试\img\image-20200305223323979.png)

+ 当退出 sychronized 代码块，锁记录的值不为null，这时使用cas 将 mark word 的值恢复给对象头

  + 成功，表明解锁成功
  + 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁的解锁流程。

##### 2. 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
    	// 同步块
    }
}
```

+ 当 Thread-1 进行轻量级加锁时，Thread-0已经对这个对象加了轻量级锁

  ![image-20200305224744162](D:\Desktop\面试\img\image-20200305224744162.png)

+ 这时Thread-1加轻量级锁失败，进入锁膨胀流程

  + 即为Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址
  + 然后自己进入 Monitor 的 EntryList BLOCKED

  ![image-20200305224934741](D:\Desktop\面试\img\image-20200305224934741.png)

+ 当Thread-0退出同步块解锁时，使用cas将Mark Word 的值恢复给对象块，失败。这时会进入重量级锁解锁流程，即按照Monitor 地址找到Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程

##### 3.自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞（阻塞就是上下文切换过程，会耗费cpu）

**自旋成功**

![image-20200305230652826](D:\Desktop\面试\img\image-20200305230652826.png)

**自旋失败**

![image-20200305230713139](D:\Desktop\面试\img\image-20200305230713139.png)

+ 自旋会占用cpu时间，单核cpu自旋就是浪费，只有多核cpu自旋才能发挥优势
+ 在java6 之后自旋是自适应的
+ java 7 之后不能控制是否开启自旋

##### 4.偏向锁

轻量级锁在没有竞争时，每次重入仍然需要执行cas操作

java6中引入了偏向锁来进一步优化：只有第一次使用cas将线程ID 设置到对象的 MarkWord 头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。

###### 偏向状态

Java对象头中 mark word 格式

![image-20200305234400291](D:\Desktop\面试\img\image-20200305234400291.png)

一个对象创建时

+ 如果开启了偏向锁（默认是开启的），那么对象创建后，markword的值为0x05，即最后三位为101，这是他的thread，epoch，age都为0
+ 偏向锁是默认延迟的，不会在程序启动时立即生效
+ 如果没有开启偏向锁，那么创建对象后，maekword的值为0x01，即最后3位为001，这是他的hashcode、age都为0，第一次用到hashcode时才会赋值（使用hashcode之后，会禁用偏向锁）

###### 撤销偏向锁

+ 调用对象hashcode
  + 调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销
  + 轻量级锁会在**锁记录**中记录 hashCode
  + 重量级锁会在 **Monitor** 中记录 hashCode
+ 其他线程使用对象
+ 调用wait/notify（需要配合一个Object Monitor 一起使用）

###### 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID

当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至
加锁线程

###### 批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象
都会变为不可偏向的，新建的对象也是不可偏向的

### 3.5 wait notify

#### 3.5.1 wait/notify 原理介绍

![image-20200306002500752](D:\Desktop\面试\img\image-20200306002500752.png)

+ Owner 线程发现条件不满足时，调用wait方法，即可进入waitset变为waiting状态
+ BLOCKED 和 WAITING 的线程都是处于阻塞状态，都不占用cpu时间片
+ BLOCKED 线程会在Owner 线程释放锁时唤醒
+ WAITING 线程会在Owner线程调用notify 或 notifyall时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争

#### 3.5.2 API介绍

+ obj.wait() 让进入 object 监视器的线程到 waitSet 等待
+ obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒
+ obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒

它们都是线程之间进行**协作**的手段，都属于 **Object 对象的方法**。必须获**得此对象的锁**，才能调用这几个方法

#### 3.5.3 wait notify 的正确姿势

**sleep(long n) 和 wait(long n) 的区别**

+ sleep是Thread的方法，而wait是Object的方法
+ sleep不需要强制和synchronized配合使用，但是wait需要
+ sleep在睡眠的同时，不会释放锁对象，但是wait在等待的时候会释放锁对象
+ 两者都会使得线程进入TIMED_WAITING 状态

```java
synchronized(lock) {
    while(条件不成立) {
    	lock.wait();
    }
    // 干活
}

//另一个线程
synchronized(lock) {
	lock.notifyAll();
}
```



### 3.6 ==(同步模式)模式：保护性暂停==

#### 3.6.1 定义

即 Guarded Suspension，**用一个线程等待另外一个线程的执行结果**

要点

+ 有一个结果需要从一个线程传递到另外一个线程，让他们关联同一个GuardedObject
+ 如果有结果不断从一个线程到另外一个线程，那么可以使用消息队列（生产者/消费者）
+ JDK中，join的实现，Future的实现，采用的就是这个模式
+ 因为要等待另一方的结果，因此归类到同步模式

![image-20200306084218855](D:\Desktop\面试\img\image-20200306084218855.png)

#### 3.6.2 实现

```java
class GuardedObject {
    private Object response;
    private final Object lock = new Object();
    
    // 获取结果
    public Object get() {
        synchronized(lock) {
            //条件不满足则等待
            while (response == null) {
                try{
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }
    
    // 返回结果
    publIc void complete(Object response) {
        synchronized(lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}
```

```java
public static void main(String[] args) {
	GuardedObject guardedObject = new GuardedObject();
	new Thread(() -> {
		try {
            // 子线程执行下载
            List<String> response = download();
            log.debug("download complete...");
            guardedObject.complete(response);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }).start();
    log.debug("waiting...");
    // 主线程阻塞等待
    Object response = guardedObject.get();
    log.debug("get response: [{}] lines", ((List<String>) response).size());
}
```

> 08:42:18.568 [main] c.TestGuardedObject - waiting...
> 08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...
> 08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines



#### 3.6.3 带超时版的 GuardedObject

```java
class GuardedObject {
    private Object response;
    private final Object lock = new Object();
    
    // 获取结果
    public Object get(long timeout) {
        synchronized(lock) {
            // 开始时间
            long begin = System.currentTimeMillis();
            // 记录经过的时间
            long timePassed = 0;
            // 等待时间
            long waitTime = timeout - timePassed;
            //条件不满足则等待
            while (response == null) {
                if (timePassed >= timeout) {
                    break;
                }
                try{
                    lock.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                timePassed = System.currentTimeMillis() - begin;
            }
            return response;
        }
    }
    
    // 返回结果
    publIc void complete(Object response) {
        synchronized(lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}
```

#### 3.6.4 join 原理

join的底层原理就是使用的**保护性暂停**设计模式

```java
public final synchronized void join(long millis) throws InterruptedException {
    // 开始时间
    long base = System.currentTimeMillis();
    // 经过的时间
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        // 就是保护式暂停中的带有超时的版本
        while (isAlive()) {
            // 等待时间
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}

public final void join() throws InterruptedException {
    join(0);
}
```

#### 3.6.5 多任务版 GuardedObject

![image-20200306105826937](D:\Desktop\面试\img\image-20200306105826937.png)

```java

```



### 3.7 ==(异步模式)模式：生成者/消费者==

#### 3.7.1 定义

要点

+ 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应
+ 消费队列可以用来平衡生产和消费的线程资源
+ 生产者进负责生产结果数据，不关心数据该如何处理，而消费者专心处理结果数据
+ 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
+ JDK中各种阻塞队列，采用的就是这种模式

![image-20200308124447626](D:\Desktop\面试\img\image-20200308124447626.png)

#### 3.7.2 实现

```java
class MessageQueue {
    // 消息队列集合
    private LinkedList<Message> list = new LinkedList<>();
    // 队列容量
    private int capcity;
    
    public MessageQueue(int capcity) {this.capcity = capcity;}
    
    // 获取消息
    public Message take() {
        // 检查队列是否为空
        synchronized (list) {
            while(list.isEmpty()) {
                try {
                    log.debug("没货了, wait");
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 从队列头部获取消息并返回
            Message message = list.removeFirst();
            log.debug("已消费消息 {}", message);
            list.notifyAll();
            return message;
        }
    }
    
    // 存入消息
    public void put(Message message) {
        synchronized (list) {
            // 检查对象是否已满
            while(list.size() == capcity) {
                try {
                    log.debug("库存已达上限, wait");
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 将消息加入队列尾部
            list.addLast(message);
            log.debug("已生产消息 {}", message);
            list.notifyAll();
        }
    }
}

final class Message {
    private int id;
    private Object value;
    
    public Message(int id, Object value) {
        this.id = id;
        this.value = value;
    }
    
    public int getId() {
        return id;
    }

    public Object getValue() {
        return value;
    }
    
    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", value=" + value +
                '}';
    } 
}
```

```java
public static void main(String[] args) {
    MessageQueue queue = new MessageQueue(2);

    for (int i = 0; i < 3; i++) {
        int id = i;
        new Thread(() -> {
            queue.put(new Message(id , "值"+id));
        }, "生产者" + i).start();
    }

    new Thread(() -> {
        while(true) {
            sleep(1);
            Message message = queue.take();
        }
    }, "消费者").start();
}
```



### 3.8 park & unpark

#### 3.8.1 基本使用

它们是 LockSupport 类中的方法

```java
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象)
```

##### 先 park 再 unpark

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
},"t1");
t1.start();
sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);
```

> 18:42:52.585 c.TestParkUnpark [t1] - start...
> 18:42:53.589 c.TestParkUnpark [t1] - park...
> 18:42:54.583 c.TestParkUnpark [main] - unpark...
> 18:42:54.583 c.TestParkUnpark [t1] - resume...

##### 先 unpark 再 park

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");
t1.start();
sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
```

> 18:43:50.765 c.TestParkUnpark [t1] - start...
> 18:43:51.764 c.TestParkUnpark [main] - unpark...
> 18:43:52.769 c.TestParkUnpark [t1] - park...
> 18:43:52.769 c.TestParkUnpark [t1] - resume...

#### 3.8.2 特点

与Object 的 wait& notify 相比

+ wait，notify 和 notifyAll 必须配合 **Object Monitor** 一起使用，而park， upark不必
+ park&unpark 是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】
+ park&unpark 可以先 unpark，而wait&notify不能先notify

#### 3.8.3 原理

**每个线程都有自己的一个 Parker 对象**，由三部分组成 _counter ， _cond 和 _mutex 

##### 先 park 再 unpark

+ 当前线程调用Unsafe.park()方法
+ 检查 _counter，本情况为0，这时获得 _mutex 互斥锁
+ 线程进入 _cond 条件变量阻塞
+ 设置 _counter = 0

![image-20200308134304486](D:\Desktop\面试\img\image-20200308134304486.png)

+ 调用Unsafe.unpark(Thread-0)方法，设置 _counter 为1
+ 唤醒 _cond 条件变量中的 Thread-0
+ Thread-0 恢复运行
+ 设置 _counter 为0

![image-20200308134044423](D:\Desktop\面试\img\image-20200308134044423.png)

##### 先 unpark 再 park

+ 调用Unsafe.unpark(Thread-0)方法，设置 _counter 为1
+ 当前线程调用 Unsafe.park()方法
+ 检查 _counter，本情况为1，这是线程无序阻塞，继续运行
+ 设置 _counter 为0

![image-20200308134754514](D:\Desktop\面试\img\image-20200308134754514.png)

### 3.9 重新理解线程状态转换

![image-20200308134935440](D:\Desktop\面试\img\image-20200308134935440.png)

假设有线程 Thread t

#### 情况1 NEW --> RUNNABLE

+ 当调用 t.start() 方法时，由  NEW --> RUNNABLE

#### 情况2 RUNNABLE <--> WAITING

t 线程用 synchronized(obj) 获取了对象锁后

+ 调用 obj.wait() 方法时候，t线程从RUNNABLE --> WAITING
+ 调用 obj.notify()，obj.notifyAll()，t.interrupt()时
  + 竞争锁成功，t 线程 WAITING --> RUNNABLE
  + 竞争锁失败，t 线程 WAITING --> BLOCKED


#### 情况3 RUNNABLE <--> WAITIN

+ 当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING
  + 注意是 **当前线程** 在t线程对象的监视器上等待
+ t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE

#### 情况4 RUNNABLE <--> WAITING

+ 当前线程调用 LockSupport.park() 方法时，当前线程从 RUNNABLE --> WAITING
+ 调用 LockSupport.unpark(目标线程) 或调用了线程的 interrupt()，当前线程从 WAITING --> RUNNABLE

#### 情况5 RUNNABLE <--> TIMED_WAITING

t 线程用 synchronized(obj) 获取了对象锁后

+ 调用 obj.wait(long n) 方法时候，t线程从RUNNABLE --> WAITING
+ t 线程等待时间超过了 n 毫秒，或调用 obj.notify()，obj.notifyAll()，t.interrupt()时
  + 竞争锁成功，t 线程 WAITING --> RUNNABLE
  + 竞争锁失败，t 线程 WAITING --> BLOCKED

#### 情况6 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING
  + 注意是当前线程在t 线程对象的监视器上等待
+ 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从
  TIMED_WAITING --> RUNNABLE

#### 情况7 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
+ 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --> RUNNABLE

#### 情况8 RUNNABLE <--> TIMED_WAITING

+ 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线
  程从 RUNNABLE --> TIMED_WAITING
+ 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从
  TIMED_WAITING--> RUNNABLE

#### 情况 9 RUNNABLE <--> BLOCKED

+ t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --> BLOCKED
+ 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然 BLOCKED

#### 情况 10 RUNNABLE <--> TERMINATED

当前线程所有代码运行完毕，进入TERMINATED



### 3.10 多把锁

#### 多把不相干的锁

一间大屋子有两个功能：睡觉、学习，互不相干。
现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低
解决方法是准备多个房间（多个对象锁）

例如

```java
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }
    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

执行

```java
BigRoom bigRoom = new BigRoom();
new Thread(() -> {
    bigRoom.compute();
},"小南").start();
new Thread(() -> {
    bigRoom.sleep();
},"小女").start();
```

某次结果

```java
12:13:54.471 [小南] c.BigRoom - study 1 小时
12:13:55.476 [小女] c.BigRoom - sleeping 2 小时
```

改进

```java
class BigRoom {
    private final Object studyRoom = new Object();
	private final Object bedRoom = new Object();
    public void sleep() {
        synchronized (studyRoom) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }
    public void study() {
        synchronized (bedRoom) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

某个执行结果

```java
12:15:35.069 [小南] c.BigRoom - study 1 小时
12:15:35.069 [小女] c.BigRoom - sleeping 2 小时
```

将锁的粒度细分

+ 好处：是可以增强并发度
+ 坏处：如果一个线程需要同时获得多把锁，就容易发生死锁

### 3.11 活跃性

#### 3.11.1 死锁

死锁：是指**两个或两个以上的进程（或线程）**在执行过程中，因**争夺资源而造成的一种互相等待的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁产生的条件

**死锁发生的条件**

- 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么**其他线程必须处于等待状态**，直到资源被释放。

- 请求和保持条件：线程T1**至少已经保持了一个资源R1占用**,但**又提出对另一个资源R2请求**，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但**又对自己保持的资源R1不释放**。

- 不剥夺条件：线程已获得的资源，**在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放**。

- 环路等待条件：在死锁发生时，**必然存在一个“进程-资源环形链”**，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）

```java
Object A = new Object();
Object B = new Object();
Thread t1 = new Thread(() -> {
    synchronized (A) {
        log.debug("lock A");
        sleep(1);
        synchronized (B) {
            log.debug("lock B");
            log.debug("操作...");
        }
    }
}, "t1");
Thread t2 = new Thread(() -> {
    synchronized (B) {
        log.debug("lock B");
        sleep(0.5);
        synchronized (A) {
            log.debug("lock A");
            log.debug("操作...");
        }
    }
}, "t2");
t1.start();
t2.start();
```

> 12:22:06.962 [t2] c.TestDeadLock - lock B
> 12:22:06.962 [t1] c.TestDeadLock - lock A

#### 3.11.2 定位死锁

+ 使用 jstack 定位死锁

```shell
jps
```

> 5840 Launcher
> 4312 RemoteMavenServer36
> 6328 TestDeadThread
> 12124
> 5516 Jps

```java
jstack 6328
```

> Found one Java-level deadlock:
>
> "t1":
>   waiting to lock monitor 0x000002857d191080 (object 0x0000000089aedcb8, a java.lang.Object),
>   which is held by "t2"
> "t2":
>   waiting to lock monitor 0x000002857d190f80 (object 0x0000000089aedca8, a java.lang.Object),
>   which is held by "t1"
>
> Java stack information for the threads listed above:
>
> "t1":
>         at TestDeadThread.lambda$main$0(TestDeadThread.java:15)
>         - waiting to lock <0x0000000089aedcb8> (a java.lang.Object)
>         - locked <0x0000000089aedca8> (a java.lang.Object)
>         at TestDeadThread$$Lambda$14/0x0000000100066840.run(Unknown Source)
>         at java.lang.Thread.run(java.base@11.0.1/Thread.java:834)
> "t2":
>         at TestDeadThread.lambda$main$1(TestDeadThread.java:30)
>         - waiting to lock <0x0000000089aedca8> (a java.lang.Object)
>         - locked <0x0000000089aedcb8> (a java.lang.Object)
>         at TestDeadThread$$Lambda$15/0x0000000100066c40.run(Unknown Source)
>         at java.lang.Thread.run(java.base@11.0.1/Thread.java:834)
>
> Found 1 deadlock.

+ 使用 jconsole 检测死锁

![image-20200308154550545](D:\Desktop\面试\img\image-20200308154550545.png)

![image-20200308154605879](D:\Desktop\面试\img\image-20200308154605879.png)



#### 3.11.3 哲学家就餐问题

```java
class Chopstick {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}	

class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }
    @Override
    public void run() {
        while (true) {
            // 获得左手筷子
            synchronized (left) {
                // 获得右手筷子
                synchronized (right) {
                    // 吃饭
                    eat();
                }
                // 放下右手筷子
            }
            // 放下左手筷子
        }
    }
}
```



#### 3.11.4 活锁

是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源

#### 3.11.5 饥饿

是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。



### 3.12 ReentrantLock

相对于 synchronized ，它具备如下特点

+ **可中断**（不会一直等待，等待可以被终止）
+ **可以设置超时时间**（等锁时间超过一定范围时，可自动释放锁资源）
+ **可以设置为公平锁**（资源竞争的公平，防止饥饿）
+ **支持多个条件变量**（sychronized 中，Monitor对象中的waitset，只要一个条件变量）

**与 synchronized 一样，都支持重入**

语法

```java
// 获取锁
reentrantLock.lock();
try {
    // 临界区
} finally {
    // 释放锁
    reentrantLock.unlock();
}
```

#### 3.12.1 可重入

可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，所以有权再次获取这把锁

如果是不可重入锁，那么第二次获得锁是，自己也会被锁挡住

```java
static ReentrantLock lock = new ReentrantLock();
public static void main(String[] args) {
    method1();
}
public static void method1() {
    lock.lock();
    try {
        log.debug("execute method1");
        method2();
    } finally {
        lock.unlock();
    }
}
public static void method2() {
    lock.lock();
    try {
        log.debug("execute method2");
        method3();
    } finally {
        lock.unlock();
    }
}
public static void method3() {
    lock.lock();
    try {
        log.debug("execute method3");
    } finally {
        lock.unlock();
    }
}
```

> 17:59:11.862 [main] c.TestReentrant - execute method1
> 17:59:11.865 [main] c.TestReentrant - execute method2
> 17:59:11.865 [main] c.TestReentrant - execute method3

#### 3.12.2 可打断

使用 Lock.lockInterruptibly() 可以打断正在等待锁的线程

线程在等待的过程中**被动的被打断**

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    try {
        // 可以打断的锁
        lock.lockInterruptibly();
    } catch (InterruptedException e) {
        e.printStackTrace();
        log.debug("等锁的过程中被打断");
        return;
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(1);
    t1.interrupt();
    log.debug("执行打断");
} finally {
    lock.unlock();
}
```

> 18:02:40.520 [main] c.TestInterrupt - 获得了锁
> 18:02:40.524 [t1] c.TestInterrupt - 启动...
> 18:02:41.530 [main] c.TestInterrupt - 执行打断
> java.lang.InterruptedException
> at
> java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr
> onizer.java:898)
> at
> java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron
> izer.java:1222)
> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)
> at java.lang.Thread.run(Thread.java:748)
> 18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断

#### 3.12.3 锁超时

如果无法获得锁,则主动放弃竞争,使用 lock.tryLock()

##### 立刻失败

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    if (!lock.tryLock()) {
        log.debug("获取立刻失败，返回");
        return;
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(2);
} finally {
    lock.unlock();
}
```

> 18:15:02.918 [main] c.TestTimeout - 获得了锁
> 18:15:02.921 [t1] c.TestTimeout - 启动...
> 18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回

##### **超时失败**

```java
ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -> {
    log.debug("启动...");
    try {
        if (!lock.tryLock(1, TimeUnit.SECONDS)) {
            log.debug("获取等待 1s 后失败，返回");
            return;
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }
}, "t1");
lock.lock();
log.debug("获得了锁");
t1.start();
try {
    sleep(2);
} finally {
    lock.unlock();
}
```

> 18:19:40.537 [main] c.TestTimeout - 获得了锁
> 18:19:40.544 [t1] c.TestTimeout - 启动...
> 18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回

##### 可以解决哲学家就餐问题

```java
class Chopstick extends ReentrantLock {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
```

```java
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            // 尝试获得左手筷子
            if (left.tryLock()) {
                try {
                    // 尝试获得右手筷子
                    if (right.tryLock()) {
                        try {
                            eat();
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock();
                }
            }
        }
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }
}
```

#### 3.12.4 公平锁



#### 3.12.5 条件变量

synchronized 中也有条件变量，就是我们讲原理是那个 waitset休息室，当条件不满足是进入 waitset休息室中等待

ReentrantLock 的条件变量比 synchronized 强大之处在于，他是支持多个变量条件的，就好比

+ synchronized 是那些不满足条件的线程都在一间休息室等消息
+ 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

**使用要点**

+ await 前要获得锁
+ await 执行后，会释放锁，进入 conditionObject 等待
+ await 的线程被唤醒（或打断，或超时）去重新竞争lock锁
+ 竞争 lock 锁成功后，从 await 后继续执行

```java
static ReentrantLock lock = new ReentrantLock();
static Condition waitCigaretteQueue = lock.newCondition();
static Condition waitbreakfastQueue = lock.newCondition();
static volatile boolean hasCigrette = false;
static volatile boolean hasBreakfast = false;
public static void main(String[] args) {
    new Thread(() -> {
        try {
            lock.lock();
            while (!hasCigrette) {
                try {
                    waitCigaretteQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("等到了它的烟");
        } finally {
            lock.unlock();
        }
    }).start();
    new Thread(() -> {
        try {
            lock.lock();
            while (!hasBreakfast) {
                try {
                    waitbreakfastQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("等到了它的早餐");
        } finally {
            lock.unlock();
        }
    }).start();
    sleep(1);
    sendBreakfast();
    sleep(1);
    sendCigarette();
}
private static void sendCigarette() {
    lock.lock();
    try {
        log.debug("送烟来了");
        hasCigrette = true;
        waitCigaretteQueue.signal();
    } finally {
        lock.unlock();
    }
}
private static void sendBreakfast() {
    lock.lock();
    try {
        log.debug("送早餐来了");
        hasBreakfast = true;
        waitbreakfastQueue.signal();
    } finally {
        lock.unlock();
    }
}
```

> 18:52:27.680 [main] c.TestCondition - 送早餐来了
> 18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐
> 18:52:28.683 [main] c.TestCondition - 送烟来了
> 18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟



### 3.13 ==(同步模式)模式：顺序控制==

#### 3.13.1 固定运行顺序

##### 1. wait&notify 版

```java
public class RunByOrder {
    static final Object lock = new Object();
    static boolean t2Runned = false;

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                while (!t2Runned) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t1: 1");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("t2: 2");
                t2Runned = true;
                lock.notify();
            }
        });

        t1.start();
        t2.start();

    }
}
```

##### 2. ReentrantLock

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class RunByOrder {
    static final ReentrantLock lock = new ReentrantLock();
    static final Condition waitSet = lock.newCondition();
    static boolean t2Runned = false;

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            lock.lock();
            try{
                while (!t2Runned) {
                    try {
                        waitSet.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t1: 1");
            } finally {
                lock.unlock();
            }
        });

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("t2: 2");
                t2Runned = true;
                waitSet.signal();
            } finally {
                lock.unlock();
            }
        });

        t1.start();
        t2.start();

    }
}
```

##### 3. park & unpark 版

+ 使用park&unpark简化该过程
+ 无论哪个线程先访问，都无所谓，并且是以线程单位暂停和恢复的，所以不需要同步对象和运行标记

```java
import java.util.concurrent.locks.LockSupport;

public class RunByOrder2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            LockSupport.park();
            System.out.println("t1 : 1");
        });
        t1.start();

        new Thread(() -> {
            System.out.println("t2 : 2");
            LockSupport.unpark(t1);
        }, "t2").start();
    }
}
```



#### 3.13.2 交替输出

##### 1. wait&notify版本

```java
public class RunByTurn {
    public static void main(String[] args) {
        WaitNotify wn = new WaitNotify(1, 5);
        new Thread(() -> {
            wn.print("a", 1, 2);
        },"t1").start();
        new Thread(() -> {
            wn.print("b", 2, 3);
        },"t2").start();
        new Thread(() -> {
            wn.print("c", 3, 1);
        },"t3").start();
    }
}

class WaitNotify {
    // 等待标记位
    private int flag;
    // 循环次数
    private int loopNumber;

    public WaitNotify(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }

    public void print(String str, int waitFlag, int nextFlag){
        for (int i = 0; i < loopNumber; i++) {
            synchronized (this) {
                while (waitFlag != flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }
}

```

> abcabcabcabcabc



##### 2. ReentrantLock

+ 有多个休息室，我们可以将不同的线程放入不同的休息室中

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class RunByTurn2 {
    public static void main(String[] args) throws InterruptedException {
        AwaitSignal as = new AwaitSignal(5);
        Condition a = as.newCondition();
        Condition b = as.newCondition();
        Condition c = as.newCondition();

        new Thread(() -> {
            as.print("a", a, b);
        },"t1").start();
        new Thread(() -> {
            as.print("b", b, c);
        },"t2").start();
        new Thread(() -> {
            as.print("c", c, a);
        },"t3").start();

        Thread.sleep(1000);
        as.lock();
        try {
            a.signal();
        } finally {
            as.unlock();
        }
    }
}

class AwaitSignal extends ReentrantLock {
    // 循环次数
    private int loopNumber;

    public AwaitSignal(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    // 打印             参数1 打印内容, 参数2 本休息室， 参数3 唤醒的休息室
    public void print(String str, Condition current, Condition next) {
        for (int i = 0; i < loopNumber; i++) {
            lock();
            try {
                current.await();
                System.out.print(str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }
}

```



##### 3. park&unpark

```java
import java.util.concurrent.locks.LockSupport;

public class RunByTurn3 {
    static Thread t1;
    static Thread t2;
    static Thread t3;

    public static void main(String[] args) {
        ParkUnpark pup = new ParkUnpark(5);
        t1 = new Thread(() -> {
            pup.print("a", t2);
        });
        t2 = new Thread(() -> {
            pup.print("b", t3);
        });
        t3 = new Thread(() -> {
            pup.print("c", t1);
        });


        t1.start();
        t2.start();
        t3.start();

        LockSupport.unpark(t1);
    }
}

class ParkUnpark {
    // 循环次数
    private int loopNumber;

    public ParkUnpark(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    public void print(String str, Thread next) {
        for (int i = 0; i < loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
}

```



### 本章小结

+ 分析多线程访问共享资源时，哪些代码片段属于临界区
+ 使用 **synchronized** 互斥解决临界区的线程安全问题
  + 掌握 synchronized 锁对象语法
  + 掌握 synchronzied 加载成员方法和静态方法语法
  + 掌握 wait/notify 同步方法
+ 使用 **lock** 互斥解决临界区的线程安全问题
  + 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量
+ 学会分析变量的线程安全性、掌握**常见线程安全类**的使用
+ 了解线程活跃性问题：死锁、活锁、饥饿
+ ==应用方面==
  + 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果
  + 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果
+ ==原理方面==
  + **monitor、synchronized 、wait/notify 原理**
  + **synchronized 进阶原理**
  + park & unpark 原理
+ ==模式方面==
  + 同步模式之保护性暂停
  + 异步模式之生产者消费者
  + 同步模式之顺序控制



## 4. 共享模型之内存

### 4.1 Java 内存模型

JMM 即 Java Memory Model，它定义了**主存、工作内存**抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等

JMM 体现在以下几个方面

+ **原子性** - 保证指令不会受到**线程上下文切换**的影响
+ **可见性** - 保证指令不会受 **CPU 缓存**的影响
+ **有序性** - 保证指令不会受 **cpu 指令并行优化**的影响



### 4.2 可见性

#### 4.2.1 例子：退不出的循环

```java
static boolean run = true;

public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while (true) {
            //...
        }
    });
    t.start();

    Thread.sleep(1);
    System.out.print("开始");
    run = false;
}
```

> 线程t无法退出循环

##### 原因分析：

+ 初始状态，t线程刚开始从主内存中读取了 run 的值到工作内存

![image-20200309205333232](D:\Desktop\面试\img\image-20200309205333232.png)

+ 因为 t 线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存到自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率

![image-20200309205818395](D:\Desktop\面试\img\image-20200309205818395.png)

+ 1s 之后，main线程修改了run的值，并同步到主存中，为t是从自己的工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![image-20200309205936445](D:\Desktop\面试\img\image-20200309205936445.png)

##### 解决办法

使用 volatile （易变关键字）

他可以用来修饰成员变量和静态成员变量，可以避免从自己的工作缓存中查找变量的值，必须到主存中获取他的值，线程操作volatile 变量都是直接操作主存

#### 4.2.2 ==(终止模式)模式：两阶段终止==

```java
class TPTInterrupt {
    private Thread thread;
    private volatile boolean stop = false;
    
    public void start() {
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (stop) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}
```

#### 4.2.3 ==(同步模式) balking==

##### 定义

Balking（犹豫）模式用在一个线程发现另外一个线程或本县城已经做了某一件相同的事，那么本线程就无需再做了

##### 实现

```java
class TPTInterrupt {
    private Thread thread;
    private volatile boolean stop = false;
    private volatile boolean starting = false;
    
    public void start() {
        // 需要加锁来保证互斥，不会被多个线程同时修改
        synchronized(this) {
            if (starting) {
                return;
            }
            starting = true;
        }
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if (stop) {
                    log.debug("料理后事")；
                    break；
                }
                try {
                    Thread.sleep(2000);
                    log.debug("保存结果")
                } catch (InterruptedException e){
                }
                // 执行监控记录
            }
        }, "监控线程");
        thread.start();
    }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}
```



### 4.3 有序性

### 4.4 volatile原理-双重检验单例模式

```java
public final class Singleton {
    private Singleton(){}
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                // 这个判断是为了第一次创建对象时，如果有一个线程进入还未创建完时，另一个线程也进入，假设这时第一个线程已经创建好对象，则第二个线程就无序再创建对象
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

+ 其中，synchronized 用来互斥
+ volatile 关键字用来防止指令重排
  + instance = new Singleton();
  + 1-创建对象
  + 2-初始化
  + 3-将对象赋值给变量引用
  + 在优化指令重排中，可能导致先执行3，后执行2，导致在这两条指令之间来的进程误以为对象已经创建完成，而直接返回导致错误。

```java
// 内部类实现单例模式
public final class Singleton {
    private Singleton(){}
    private static class LazyOut{
        private final static Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance(){
        return LazyOut.INSTANCE;
    }
}
```



## 5. 共享模型之无锁

> + CAS 与 volatile
> + 原子整数
> + 原子引用
> + 原子累加器
> + Unsafe

### 5.1 用CAS的无锁方式来保证原子性

例子：一个取款的例子

```java
class AccountUnsafe implements Account {
    private Integer balance;
    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }
    @Override
    public Integer getBalance() {
        return balance;
    }
    @Override
    public void withdraw(Integer amount) {
        balance -= amount;
    }
}
```

balance是一个共享资源，会出现线程不安全的情况，我们可以采用有锁和无锁两种方式来保证原子性

#### **加锁版本**

```java
class AccountUnsafe implements Account {
    private Integer balance;
    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }
    @Override
    public synchronized Integer getBalance() {
        return balance;
    }
    @Override
    public synchronized void withdraw(Integer amount) {
        balance -= amount;
    }
}
```

#### **无锁版本**

```java
class AccountUnsafe implements Account {
    private AtomicInteger balance;
    public AccountUnsafe(Integer balance) {
        this.balance = new AtomicInteger(balance);
    }
    @Override
    public Integer getBalance() {
        return balance.get();
    }
    @Override
    public void withdraw(Integer amount) {
        while (true) {
            int prev = balance.get();
            int next = prev - amount;
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

### 5.2 CAS 与 volatile

cas 如何实现原子性

```java
public void withdraw(Integer amount) {
    while(true) {
        // 需要不断尝试，直到成功为止
        while (true) {
            // 比如拿到了旧值 1000
            int prev = balance.get();
            // 在这个基础上 1000-10 = 990
            int next = prev - amount;
            /*
    compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值
    - 不一致了，next 作废，返回 false 表示失败
    比如，别的线程已经做了减法，当前值已经被减成了 990
    那么本线程的这次 990 就作废了，进入 while 下次循环重试
    - 一致，以 next 设置为新值，返回 true 表示成功
    */
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

其中的关键是 **compareAndSet**，它的简称就是 CAS ，它必须是原子操作。

![image-20200310113059098](D:\Desktop\面试\img\image-20200310113059098.png)

#### 5.2.1 volatile

获取共享变量时，为了保证该变量的可变性，需要使用volatile修饰

他可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。

cas必须**借助 volatile 才能读取到共享变量的最新值**来实现【比较并转换】的效果

#### 5.2.2 为什么无锁的效率高

+ 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized 会让线程在没有获得锁的时候，发生**上下文切换**，进入阻塞
+ 也即，多核cpu，无锁情况下不会导致上下文切换，从而提高效率。

#### 5.2.3 CAS特点

结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少，多核CPU的场景下。

+ CAS 是基于**乐观锁**的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，只需重读即可
+ synchronized 是基于**悲观锁**的思想：最悲观的估计，将共享变量锁住，从而防止其他线程不能够来修改共享变量
+ CAS 体现的是 **无锁并发、无阻塞并发**
  + 因为没有使用 synchronized ，所以线程不会陷入阻塞，这是效率提升的因素之一
  + 如果竞争激烈，重试必然频繁发生，反而效率会受到影响。

### 5.3 JUC并发包提供的原子类

#### 5.3.1 原子整数

+ AtomicInteger
+ AtomicBoolean
+ AtomicLong

AtomicInteger 常见方法

```java
AtomicInteger i = new AtomicInteger(0);

// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());

// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());

// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());

// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());

// 获取并加值（i = 0, 结果 i = 5, 返回 0）
System.out.println(i.getAndAdd(5));

// 加值并获取（i = 5, 结果 i = 0, 返回 0）
System.out.println(i.addAndGet(-5));

// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.getAndUpdate(p -> p - 2));

// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.updateAndGet(p -> p + 2));

// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));

// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
```

#### 5.3.2 原子数组

+ AtomicIntegerArray
+ AtomicLongArray
+ AtomicReferenceArray

#### 5.3.3 原子引用

+ AtomicReference
+ AtomicStampedReference
  + 可以通过版本号来判断共享变量的值是否改变
+ AtomicMarkableReference
  + 只是单纯的关心共享变量是否被修改过

#### 5.3.4 字段更新器

如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。

+ AtomicReferenceFieldUpdater // 域  字段
+ AtomicIntegerFieldUpdater
+ AtomicLongFieldUpdater

利用字段更新器，可以针对对象的某个域（file）进行原子操作，只能配合volalite 修饰的字段使用，否则会出现异常

```java
public class Test5 {
    private volatile int field;
    public static void main(String[] args) {
        AtomicIntegerFieldUpdater fieldUpdater =AtomicIntegerFieldUpdater.newUpdater(Test5.class, "field");
        Test5 test5 = new Test5();
        fieldUpdater.compareAndSet(test5, 0, 10);
        // 修改成功 field = 10
        System.out.println(test5.field);
        // 修改成功 field = 20
        fieldUpdater.compareAndSet(test5, 10, 20);
        System.out.println(test5.field);
        // 修改失败 field = 20
        fieldUpdater.compareAndSet(test5, 10, 30);
        System.out.println(test5.field);
    }
}
```



## 6. 共享模型之不可变

> + 不可变类的使用
> + 不可变类设计
> + 无状态类设计

### 6.1 日期转换的问题

**问题提出**

下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        try {
            System.out.println(sdf.parse("1951-04-21"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }).start();
}
```

> java.lang.NumberFormatException: For input string: ""
> 	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
> 	at java.base/java.lang.Long.parseLong(Long.java:702)
> 	at java.base/java.lang.Long.parseLong(Long.java:817)
> 	at java.base/java.text.DigitList.getLong(DigitList.java:195)
> 	at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2123)
> 	at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)
> 	at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)
> 	at java.base/java.text.DateFormat.parse(DateFormat.java:393)
> 	at n6.Test1.lambda$main$0(Test1.java:11)
> 	at java.base/java.lang.Thread.run(Thread.java:834)
>
> Sat Apr 21 00:00:00 CST 1951
> Sat Apr 21 00:00:00 CST 1951
> Sat Apr 21 00:00:00 CST 1951
> Sat Apr 21 00:00:00 CST 1951
> Thu Apr 21 00:00:00 CST 5121
> Wed Apr 21 00:00:00 CST 1451
> Sat Apr 21 00:00:00 CST 1951

会带来线程竞争问题，所以需要改进

**思路：同步锁**

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        synchronized (sdf){
            try {
                System.out.println(sdf.parse("1951-04-21"));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
}
```

**不可变类**

如果一个对象在不能够修改其内部状态（属性），那么他就是线程安全的，因为不存在并发修改啊！

```java
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
    new Thread(() -> {
        LocalDate date = dtf.parse("2018-10-01", LocalDate::from);
        log.debug("{}", date);
    }).start();
}
```

### 6.2 不可变设计

String类也是不可变的

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0
    // ...
}
```

#### final 的使用

发现该类、类中所有属性都是 final 的

+ 属性final 修饰，保证了**该属性是只读的，不能修改**
+ 类用 final 修饰保证了**该类中的方法不能被覆盖**，防止子类无意间破坏不可变性。

#### 保护性拷贝

以substring为例

```java
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
```

String 的构造方法创建了一个新字符串

```java
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}
```

底层在欧早新字符串对象时，会生成新的 char[] value,对内容进行复制。

这种通过创建副本对象来避免共享的手段称之为【保护性拷贝】

### 6.3 ==模式：享元模式==

#### 1. 简介

+ 定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时

  > wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as
  > possible with other similar objects

+ 出自 "Gang of Four" design patterns
+ 归类 Structual patterns

#### 2. 体现

##### 2.1 包装类

在JDK中 Boolean、Byte、Short，Integer、Long、Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128- 127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：

```java
public static Long valueOf(long l) {
    final int offset = 128;
    if (l >= -128 && l <= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}
```

> 注意：
>
> + Byte, Short, Long 缓存的范围都是 -128~127
> + Character 缓存的范围是 0~127
> + Integer的默认范围是 -128~127
>   + 最小值不能变
>   + 但最大值可以通过调整虚拟机参数 `
>     -Djava.lang.Integer.IntegerCache.high` 来改变
> + Boolean 缓存了 TRUE 和 FALSE

##### 2.2 String 常量池

+ 字符串常量池类似一个缓存区，在创建字符串常量时
  + 首先检查字符串常量池中是否存在该字符串，
  + 存在该字符串，返回引用实例，
  + 不存在，实例化该字符串并放入池中。
+ 实现基础
  + 字符串时不可变的，就不用担心数据冲突问题
  + 运行时实例创建的全局字符串常量池中有一个表，总是为池中每一个唯一的字符串对象维护一个引用，就可以防止其被垃圾回收。
+ String类中的equal被重写，用来返回两个字符串对象的值是否相同。

#### 3. DIY

```java
class pool {
    // 1. 连接池的大小
    private final int poolSize;

    // 2. 连接池的连接对象数组
    private Connection[] connections;

    // 3. 连接数组状态 0 表示空闲 1 表示繁忙
    private AtomicIntegerArray status;

    // 4. 构造函数
    public pool(int poolSize) {
        this.poolSize = poolSize;
        connections = new Connection[poolSize];
        status = new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i < poolSize; i++) {
            connections[i] = new MockConnection();
        }
    }

    // 5. 借连接
    public Connection borrow() {
        while (true) {
            // 循环获取连接
            for (int i = 0; i < poolSize; i++) {
                if (status.get(i) == 0) {
                    // 需要使用cas的无锁机制来保证写入时的线程安全
                    if (status.compareAndSet(i, 0, 1)) {
                        return connections[i];
                    }
                }
            }
            // 如果没有连接，则进入等待室等待
            synchronized (this) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // 6. 释放连接
    public void free(Connection conn) {
        for (int i = 0; i < poolSize; i++) {
            if (connections[i] == conn) {
                status.set(i, 0);
                synchronized (this) {
                    this.notifyAll();
                }
                break;
            }
        }
       
    }
}

class MockConnection implements Connection {
    // 实现略
}
```

 

## 7. 共享模型之工具

### 7.1 线程池

#### 7.1.1 自定义线程池

![image-20200312110158919](D:\Desktop\面试\img\image-20200312110158919.png)

+ 阻塞队列，用来平衡消费者和生成者之间的生产任务关系
  + 一个take方法
  + 一个poll方法，带等待时间
  + 一个put方法

+ 线程池
  + 使用了享元模式，用一定量的线程来执行更多的任务

#### 7.1.2 ThreadPoolExecutor

![image-20200312154731247](E:\研究生\面试\img\image-20200312154731247.png)

##### 1. 线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位 表示线程数量

|   状态名   | 高3位 | 接收新任务 | 处理阻塞队列 | 说明                                         |
| :--------: | :---: | ---------- | ------------ | -------------------------------------------- |
|  RUNNING   |  111  | Y          | Y            |                                              |
|  SHUTDOWN  |  000  | N          | Y            | 不会接受新任务，但会处理阻塞队列中剩余的任务 |
|    STOP    |  001  | N          | N            | 会中断正在执行的任务，并抛弃阻塞队列任务     |
|  TIDYING   |  010  | -          | -            | 任务全执行完毕，活动线程为0即将进入终结      |
| TERMINATED |  011  | -          | -            | 终结状态                                     |

这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值。

```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));

// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

##### 2. 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

+ corePoolSize 核心线程数目（最多保留的线程数）
+ maximumPoolSize 最大线程数目
+ keepAliveTime 生存时间 - 针对救急线程
+ unit 时间单位 - 针对救急线程
+ workQueue 阻塞队列
+ threadFactory 线程工厂 - 可以为线程创建时起个好名字
+ handler 拒绝策略
  + 当任务数在阻塞队列中都放不下的时候，调用者可以使用的执行策略

**工作方式**

![image-20200312163219372](D:\Desktop\面试\img\image-20200312163219372.png)

+ 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务

+ 当线程达到 corePoolSize 并没有线程空闲，这是再加入任务，新加的任务会被加入 workQueue 队列排队，直到有空闲的线程

+ 如果队列选择了**有界队列**，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急

+ 如果线程达到了 maximumPoolSize 仍然有新任务，这时会执行拒绝策略。拒绝策略 jdk 提供了 4 中实现

  + AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这时默认策略
  + CallerRunsPolicy 让调用者运行任务
  + DiscardPolicy 放弃本次任务
  + DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之

  ![image-20200312163651974](D:\Desktop\面试\img\image-20200312163651974.png)

+ 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束，节省资源，这个时间由 keepAliveTime 和 unit 来控制。



根据这个构造方法，**JDK Executor 类**中提供了众多工厂方法来创建各种用途的线程池

##### 3.newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

特点

+ 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
+ 阻塞队列是无界的，可以放任意数量的任务
+ 也可以重写工厂方法，不重写则使用默认的工厂

> **适用于任务量已知，相对耗时的任务**

##### 4. newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

特点

+ 核心线程数为0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲时间是60s，意味着
  + 全部都是救急线程（60s后可以回收）
  + 救急线程可以无限创建
+ 队列采用了SynchronousQueue 实现，特点是，它没有容量，没有线程来取是放不进去的（一手交钱，一手交货）

> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程。
>
> 适合任务数比较密集，但每个任务执行时间较短的情况。

##### 5. newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

使用场景：

希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放

**区别**

+ 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证线程池的正常工作
+ Executor.newSingleThreadExecutor() 线程个数始终为1，不能修改
  + FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外保护了 ExecutorService 接口，因此不能调用ThreadPoolExecutor 中特有的方法
+ Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改
  + 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改



##### 6. 提交任务

```java
// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结果
<T> Future<T> submit(Callable<T> task);


// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
    throws InterruptedException;
// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                              long timeout, TimeUnit unit)
    throws InterruptedException;


// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
    throws InterruptedException, ExecutionException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks,
                long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
```

##### 7.关闭线程池

**shutdown**

```java
/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();
```

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(SHUTDOWN);
        // 仅会打断空闲线程
        interruptIdleWorkers();
        onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
    tryTerminate();
}
```

**shutdownNow**

```java
/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List<Runnable> shutdownNow();
```

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(STOP);
        // 打断所有线程
        interruptWorkers();
        // 获取队列中剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结
    tryTerminate();
    return tasks;
}
```

#### 7.1.3 ==异步模式：worker Thread==

##### 1.定义

让有限的工作线程（worker thread）来轮流异步处理无限度的任务。也可以将其归类为分工模式，他的典型实现就是线程池，也体现了经典设计模式中的享元模式

例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）

**注意**，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率

例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工

##### 2.饥饿

固定大小线程池会有饥饿现象

+ 两个工人是同一个线程池中的两个线程
+ 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作
  + 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待
  + 后厨做菜：没啥说的，做就是了
+ 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好
+ 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿

##### 3. 创建多少线程合适

+ 过小会导致程序不能充分利用系统资源、容易导致饥饿
+ 过大会导致更多的线程上下文切换，占用更多内存

###### 3.1 CPU 密集型运算

通常采用 `cpu 核数 + 1` 能够实现最优的CPU利用率， +1 是保证当线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不能被浪费。

###### 3.2 I/O 密集型运算

CPU 不总是处于繁忙状态，例如，当你执行业务计算是，这时候会使用CPU资源，但当你执行 I/O 操作时，远程RPC 调用时，包括进行数据库操作是，这时候CPU 就闲下来了，你可以利用多线程提高它的利用率

经验公式

`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间`



### 7.2 J.U.C

#### 7.2.1 AQS原理

AQS全程是 AbstractQueuedSynchronizer ，是**阻塞式锁**和相关的**同步器工具**的框架。

##### **1. 特点**

+ **用 state 属性来表示资源的状态**（分独占式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁

  ```JAVA
  //共享变量，使用volatile修饰保证线程可见性
  private volatile int state;
  ```

  + getState - 获取 state 状态
  + setState - 设置 state 状态
  + compareAndSetState - cas 机制设置 state 状态
  + 独占模式是只有一个线程能够访问资源，而共性模式可以允许多个线程访问资源

+ 提供了基于 FIFO 的等待队列，类似与 Monitor 的 EntryList

+ 条件变量来实现等待、唤醒机制，支持多个条件变量，类似与 Monitor 的 WaitSet

##### **2. AQS底层使用了模板方法模式**

同步器的设计时基于模板方法的，如果需要自定义同步器一般的方式都是

+ 使用者继承 AQS并重写指定的方法
+ 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

**需要重写的方法（默认抛出 UnsupportedOperationException）**

```java
isHeldExclusively()// 线程是否正在独占资源，只有用到conditon才需要去实现它
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

##### 3. 设计

AQS 要实现的功能目标

+ 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire
+ 获取锁超时机制
+ 通过打断取消机制
+ 独占机制和共享机制
+ 条件不满足时的等待机制

AQS 的基本思想

获取锁逻辑

```java
while(state 状态不允许获取) {
    if(队列中还没有此线程) {
        入队并阻塞
    }
}
当前线程出队
```

释放锁的逻辑

```java
if (state 状态允许) {
    恢复阻塞的线程
}
```

要点

+ 原子维护 state 状态
+ 阻塞及恢复线程
+ 维护队列

#### 7.2.2 ReentrantLock 原理

![image-20200315101311832](D:\Desktop\面试\img\image-20200315101311832.png)

##### 1. 非公平锁实现原理

###### **加锁解锁流程**

先从构造器开始看，默认是非公平锁实现

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

NonfairSync 继承自 AQS

+ 没有竞争

  + 线程将 state 设置为 1， 同时将锁定拥有设置为 该线程

  ![image-20200315101715177](E:\研究生\面试\img\image-20200315101715177.png)

+ 第一个竞争出现时

  ![image-20200315101925225](E:\研究生\面试\img\image-20200315101925225.png)

  Thread-1

  + cas 尝试将 state 由 0 改为 1，失败
  + 进入 tryAcquire 逻辑，这时 state 已经是1，结果也是失败
  + 加下来进入 addWaiter 逻辑，构造 Node 队列
    + 途中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态
    + Node 的创建是懒惰的
    + 其中 第一个Node 称为 Dummy 或哨兵，用来占位，并不管理线程

  ![image-20200315102315510](E:\研究生\面试\img\image-20200315102315510.png)

  当前线程进入 acquireQueued 逻辑

  + acquireQueued 会在一个死循环中不断尝试获取锁，失败后进入 park 阻塞
  + 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败
  + 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false

  ![image-20200315102831867](E:\研究生\面试\img\image-20200315102831867.png)

  + shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败
  + 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true
  + 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）

  ![image-20200315102958006](E:\研究生\面试\img\image-20200315102958006.png)

+ 再次有多个线程经历上述过程竞争失败，就会变成这个样子


![image-20200315103141919](E:\研究生\面试\img\image-20200315103141919.png)

+ Thread-0释放锁，进入tryRelease 流程，如果成功

  + 设置 exclusiveOwnerThread 为 null
  + state = 0
  + 当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程
  + 找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1

![image-20200315105350230](E:\研究生\面试\img\image-20200315105350230.png)

+ 在 thread-1 的acquireQueued 流程
  + 如果加锁成功（没有竞争），会设置
    + usiveOwnerThread 为 Thread-1，state = 1
    + head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread
    + 原本的 head 因为从链表断开，而可被垃圾回收（p.next = null）

![image-20200315104928293](E:\研究生\面试\img\image-20200315104928293.png)

+ 如果此时有其他线程来竞争，假如不巧又被 thread-4 占先
  + Thread-4 被设置为 exclusiveOwnerThread，state = 1
    Thread-1 
  + 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞



##### 2.  可重入原理

在进入tryacquire() 方法时，若此时状态值不为0，会判断该线程和owner线程是否一致，如果一致，则state++；

释放过程中 tryrelease() 方法，会对state--，假如减一之后还不是0，说明有锁重入，此时标记变量free还是false返回，但是实际上是解掉了一层锁。



##### 3. 可打断原理

###### 不可打断模式

```java
// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    // ...
    private final boolean parkAndCheckInterrupt() {
        // 如果打断标记已经是 true, 则 park 会失效
        LockSupport.park(this);
        // interrupted 会清除打断标记
        return Thread.interrupted();
    }
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null;
                    failed = false;
                    // 还是需要获得锁后, 才能返回打断状态
                    return interrupted;
                }
                if (
                    shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt()
                ) {
                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    public final void acquire(int arg) {
        if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
            // 如果打断状态为 true
            selfInterrupt();
        }
    }
    static void selfInterrupt() {
        // 重新产生一次中断
        Thread.currentThread().interrupt();
    }
}
```

###### 可打断模式

```java
static final class NonfairSync extends Sync {
    public final void acquireInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        // 如果没有获得到锁, 进入 ㈠
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }
    // ㈠ 可打断的获取锁流程
    private void doAcquireInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt()) {
                    // 在 park 过程中如果被 interrupt 会进入此
                    // 这时候抛出异常, 而不会再次进入 for (;;)
                    throw new InterruptedException();
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
}
```

##### 4.公平锁的实现

在 tryAcquire 时候，会先去判断一下 Node 队列中，是否有前驱节点，没有才会去竞争

##### 5. 条件变量实现原理

每个条件变量都对应着一个等待队列，其实现类是 conditionObject

await 流程





#### 7.2.3 ConcurrentHashMap

##### 1. HashMap

HashMap在 1.8 版本之前 和 1.8 版本之后是不一样的

在**1.8版本之前**，HashMap 底层是数组和链表结合一起使用的散列链表，hashMap通过key 的hashcode得到hash值，然后通过 (n-1)&hash 判断当前元素存放的位置，如果当前元素存在元素的话，就判断该元素与要存入的元素的hash值以及 key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突

拉链法采用的是头插法，也即新加入的元素会防止在链表的头部，在多线程操作出现扩容时，会出现并发死链的问题，假如thread-01它达到装载因子上限需要扩容，在这时，thread-02率先进行了扩容，因为使用头插法，会导致链表的顺序与先前的相反，当切换到thread-01时，在复制到新链表中，出现当前节点指向的下一个节点又指回当前节点的问题，从而出现了死链

在 **JDK1.8 之后**，通过将链表的插入法改为尾插法来解决并发死链的问题，同时，当链表的长度大于8时，会先进行扩容，当数组长度为64时，就将链表上升为红黑树来提高性能。

但是依旧无法改变HashMap中，线程不安全的情况。

hashTable JDK中遗留的线程安全的类，他是在HashMap的基础上，加了 synchronized 来保证线程安全，但是加这种重量级锁，并不高效，在juc并发包中，提供了效率更为高效的 concurrentHashMap。

##### 2. ConcurrentHashMap

jdk1.7 中实现线程安全的方式

+ 使用**分段锁**对整个桶数组进行了**分割分段**，每一把锁只锁锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发度，分段的默认大小是16，不能改变
+ segment数组结构底层实现 **reentrantLock**，扮演着锁的结构

JDK 1.8 中实现线程安全的方式

+ 摈弃了分段锁的概念，而是直接用 node数组 + 链表 + 红黑树的数据结构实现，并发控制使用synchronized 和cas 来操作
+ synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提高了n倍
+ 加之 jdk 1.6 版本之后，对**synchronized 锁进行了优化**，使得concurrenthashmap就像是优化且线程安全的hashmap。













