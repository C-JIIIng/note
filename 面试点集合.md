# 面试



## == == ==专业知识== == == 

## `Java`

### 1. 基础知识

---

#### 1.1 重载和重写的区别

+ **重载**：
  + 发生在同一个类中
  + 方法名必须相同，
  + 参数类型不同，个数不同，顺序不同，
  + 方法返回值和访问修饰符可以不同
  + 发生在编译时
+ **重写**
  + 发生在父子类类中
  + 方法名和参数列表必须相同
  + 返回值范围小于等于父类
  + 抛出异常范围小于父类
  + 访问修饰符范围大于等于父类
  + 如果父类方法访问修饰符为private，则子类就不能重写该方法

---

#### 1.2 String 和 StringBuffer 和 StringBuilder 的区别是什么？String为什么是不可变的？

**可变性**

+ String类中使用 `final` 关键字符数组保存字符串，`private final char value[]` ，所以String对象是不可变的。
+ StringBuilder 和 StringBuffer 都是继承 AbstractStringBuilder 类，在AbstractStringBuilder 中也是使用字符数组来保存字符串，但是没有用 final 关键字修饰，所以这两个对象是可变的。

**线程安全性**

+ String 中的对象是不可变的，所以可以理解为常量，线程安全
+ StringBuffer 对方法加入了同步锁，所以是安全的
+ StringBuilder 没有对方法加同步锁，所以是非线程安全的

**性能**

+ 每次对String类型进行改变时，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。
+ StringBuffer 每次都对 StringBuffer 本身进行操作，而不是生成新的对象并改变对象引用。
+ t同样情况，StringBuilder也会得到一些新能提升，但是要冒着很多线程不安全的风险

**综上**

+ 操作少量数据 -> String
+ 单线程操作字符串缓存区下操作大量数据 -> StringBuilder
+ 多线程操作字符串缓存区下操作大量数据 -> StringBuffer

---

#### 1.3 自动装箱和拆箱

+ 装箱：将基本类型用它们对应的引用类型包装起来
+ 拆箱：将包装类型转换为基本数据类型

---

#### 1.4 == 和 equals

**==**：

+ 作用是比较两个对象的地址是不是相同，也即判断两个对象是不是同一个对象
+ 基本数据类型比较的是值
+ 引用数据类型比较的是内存地址
+ 当 "=="运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。

**equals()**

+ 作用也是判断两个对象是否相等
+ 类如果没有覆盖 equals 方法，则通过equals 与 == 相同
+ 类如果覆盖了 equals 方法，一般，都是来比较两个对象的内容



注：

+ String 中的 equals 方法是被重写过的，比较的是对象的值
+ 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有，就将他赋给当前引用，否则就在常量池中重新创建一个 String 对象

---

#### 1.5  final

final 关键字主要用三个地方：变量、方法、类

+ 对于一个 final **变量**
  + 如果是**基本数据类型**的变量，则数据值一旦被初始化之后便不能更改
  + 如果是**引用类型**的变量，则在对其初始化之后便不能再指向另一个对象，但是对象的属性可以改变
+ final 修饰一个方法
  + 会将方法锁定，防止任何继承类修改他的含义
  + 类中所有的private方法都隐式地指定为 final
+ final 修饰一个**类**
  + 表示该类不能被继承，类中所有成员方法都会被指定为final方法

---

#### 1.6 static 关键字

+ 静态变量

  + 静态变量又称类变量，也即这个变量属于类，类所有的实例都共享静态变量，可以通过类名来访问，静态变量在内存中只存在一份
  + 实例变量，每创建一个实例就会产生一个实例变量，与该实例同生共死

  ```java
  public class A {
      private int x;         // 实例变量
      private static int y;  // 静态变量
      public static void main(String[] args) {
          // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
          A a = new A();
          int x = a.x;
          int y = A.y;
      }
  }
  ```

+ 静态方法

  + 在类加载的时候就存在了，**不依赖于任何实例**
  + 所有的类方法都**必须实现**
  + **只能访问所属类的静态字段和静态方法**，方法中不能有this 和 super 关键字，因为这两个关键字与具体对象关联

+ 静态代码块

  + 在类初始化时运行一次

+ 初始化顺序

  存在继承的情况下，初始化顺序为：

  + 父类（静态变量、静态语句块）
  + 子类（静态变量、静态语句块）
  + 父类（实例变量、普通语句块）
  + 父类（构造函数）
  + 子类（实例变量、普通语句块）
  + 子类（构造函数）

---

#### 1.7 Object 类的常见方法

Object是所有类的父类

```java
//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。
public final native Class<?> getClass()

// native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。 
public native int hashCode() 
    
//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。   
public boolean equals(Object obj)
    
/*
naitive方法，用于创建并返回当前对象的一份拷贝。
一般情况下，对于任何对象 x，表达式 x.clone() != x 为true,x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生
CloneNotSupportedException异常。
*/
protected native Object clone() throws CloneNotSupportedException
    
//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。
public String toString()
    
//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()
 
//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()
    
//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
public final native void wait(long timeout) throws InterruptedException

//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
public final void wait(long timeout, int nanos) throws InterruptedException
    
//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException
    
//实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
    
```

---

#### 1.8 Java 中的异常处理

所有的异常都继承 `Throwable` 类，包括两个重要的子类，Exception(异常) 和 Error(错误)

**Error**

+ 是指**程序无法处理的错误**，大多数错误与代码编写者执行的操作无关，表示 **JVM 出现问题**
+ 如 Java 虚拟机运行错误(Virtual MachineError) ，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。
+ 这些异常发生时，虚拟机一般会选择终止线程

**Exception**

+ 是指程序本身可以处理的异常
+ Exception 类有一个重要的子类 **RuntimeException**，由jvm抛出，
+ NullPointerException（要访问的变量没有引用任何对象时，抛出该
  异常）
+ ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）
+ ArrayIndexOutOfBoundsException （下标越界异常）。

**Throwable类常用方法**

```java
public string getMessage() // 返回异常发生时的详细信息
public stirng toString() // 返回异常发生时的简要描述
public string getLocalizedMessage() // 返回异常对象的本地化信息，子类若没有覆盖，则返回信息与 getMessage 相同
public void printStcakTrace() // 在控制台上打印Throwable 对象封装的信息   
```

**异常处理总结**

+ try块：用于捕获异常，其后可以接0个或多个catch块，如果没有catch块，则必须跟一个finally块
+ catch块：用于处理try捕获到的异常
+ finally块：无论是否捕获或处理成功，finally块里的语句都会被执行，当try和catch块中有return时，finally语句块将在方法返回之前执行。

**finally块不会被执行的情况**

+ finally语句块中发生了异常
+ 前面代码用了 System.exit() 退出程序
+ 程序所在的线程死亡
+ 关闭CPU

---

#### 1.9 接口和抽象类的区别是什么

+ 接口的**方法**默认是public，所有方法在接口中**不能实现**；抽象类可以有非抽象方法
+ 接口中的**实例变量**默认是 final 类型的；抽象类中不一定
+ 一个类可以**实现**多可接口，但是最多只能实现一个抽象类
+ 一个类实现接口的话，要实现接口的所有方法，抽象类不一定
+ 接口不能用 new 实例化，但是可以声明，但是必须引用一个实现该接口的对象；抽象类也不能实例化，只能被继承
+ 抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范

---



### 2.集合框架

---

#### 2.1 ArrayList 与 LinkedList 异同

+ 二者都不保证线程安全
+ ArrayList 底层使用的是数组；LinkedList底层使用的是双向链表
+ ArrayList底层是用数组存储，所以插入和删除元素的时间复杂度受到元素位置的影响，近似O(n)；而LinkedList采用链表存储，所以插入和删除元素的时间复杂度不受元素位置印象，为O(1)
+ ArrayList支持通过元素的序号快速访问元素；而LinkedList不支持高效的随机元素访问
+ ArrayList空间浪费主要体现在list列表的结尾会预留一定的容量；而LinkedList空间浪费则体现在每个元素都要多存放指针

---

#### 2.2 ArrayList 和 Vector区别

+ Vector类的所有方法都是同步的，两个线程可以安全的访问一个Vector对象
+ ArrayList不是同步的，所以不需要保证线程安全是可以使用

---

#### 2.3 HashMap的底层实现

JDK1.8以前，HashMap底层是 **数组加链表** 结合在一起使用的。

HashMap通过 KEY 的 hashCode 得到hash值，然后通过 `(n - 1) & hash值` 判断当前元素存储的位置，如果当前元素存在，就要使用equal方法来判断是否是同一个对象，如果是就覆盖，如果不是就用拉链法解决冲突。

JDK1.8 以后，解决哈希冲突有较大变化，当链表长度大于阈值（默认为8），将链表转化为红黑树，以减少搜索时间。

---

#### 2.4 HashMap 和 HashTable 的区别

+ HashMap是非线程安全的，HashTable是线程安全的
+ HashMap的效率会比HashTable高一些
+ HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个null值，但是HashTable put的键有一个null，就会抛出空指针异常

---

#### 2.5 HashMap 的长度为什么是2的幂次方

hash值的范围很大，我们需要对哈希值区域得到数组下标，`(n - 1) & hash`，需要利用长度为2的幂次方，同时，位运算的效率较高。



### 3.多线程

---





### 4.虚拟机

----

####  4.1 运行时数据区

![1576807303366](E:\研究生\面试\img\1576807303366.png)

+ **程序计数器**
  + **线程私有**，是一块比较小的内存空间
  + **是当前线程所执行的字节码的行号指示器**
  + 执行Java方法，记录虚拟机字节码指令的地址，如果是native方法，则为空
  + 是JVM 中唯一一个没有规定任何 OutOfMemoryError 情况的区域
+ **虚拟机栈**
  + **线程私有**
  + 是描述 **Java 方法执行的内存模型**，每个方法在执行的同时都会创建一个**栈帧（**Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  + 栈帧随方法调用而创建，随方法结束而销毁
+ **本地方法区**
  + **线程私有**
  + 和虚拟机栈作用类似，是为 native 方法服务的
+ **堆**
  + **线程共享**
  + **创建的对象和数组都存在Java 堆对象中，也是垃圾收集器进行垃圾收集的最重要的内存区域**
  + 可细分为新生代和老年代
+ **方法区**
  + **线程共享**
  + 即我们常说的永久代，用于存储 JVM 加载的**类信息、常量、静态变量**，即时编译器编译后的代码等数据。
  + ==运行时常量池==是方法区的一部分。Class文件中的常量池（用于存放编译器生成的各种字面量和符号引用）在类加载后存放在方法区的运行时常量池中。

---

#### 4.2 Java中的新生代，老年代和永久代的区别

> Java 堆从 GC 的角度可以分为新生代和老年代
>
> 永久代指内存的永久保存区域

##### **新生代**

+ 用来**存放新生的对象**，一般占堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。
+ 新生代分为 Eden、ServivorFrom、ServivorTo 三个区
+ Eden区是新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。**到该区域内存不够时，会触发MinorGC**，对新生代进行一次垃圾回收
+ ServivorFrom区，是存放上一次GC 的幸存者，作为这一次GC的被扫描者
+ ServivorTo区，保留了一次MinorGC 过程中的幸存者。

##### **MinorGC算法**

+ 首先，将 eden 和 servivorFrom区域中存活的对象**复制**到 servivorTo区域中（如果有对象年龄达到老年的标准，默认15，就复制到老年代区），同时把这些对象的年龄+1
+ 然后，清空eden 和 servivorFrom 区域中的对象
+ 最后，将servivorFrom区域 和 servivorTo区域互换。

##### **老年代**

+ 存放应用程序中**生命周期长的内存对象**
+ 老年代对象比较稳定，所以不会频繁地执行MajorGC回收。
+ 在执行 MajorGC 前一般都会进行一次 MinorGC， 使得新生代的对象晋升入老年代，导致空间不够时才触发
+ 当无法找到足够大的连续空间分配给新创建的较大对象时，也会触发一次MajorGC 进行垃圾回收腾出空间

##### **MajorGC 算法**

+ 采用**标记清除**算法
+ 首先扫描一次所有的老年代，标记出存活的对象
+ 然后回收没有标记的对象
+ MajorGC会产生内存锁片，为了减少内存损失，一般需要进行合并方便下次直接分配。
+ 当老年代也装不下了，就会抛出 OutOfMemory 异常


**永久代**

+ 值内存的永久保存区域，主要用于存放 Class 和 元数据信息。
+ GC 不会再主程序运行时对永久区进行清理
+ 当 Class 增多，永久区内存不够，会抛出 OutOfMemory 异常

##### 元空间

Java8中，永久代被移除，被一个称为“**元数据区**”的区域取代，元空间不存在虚拟机中，存在本地内存中。类的元数据存入**本地内存**，字符串池和类的静态变量放入Java堆中。

---

#### 4.3 垃圾回收和算法

##### 如何确定垃圾？

+ 引用计数法
  + 即一个对象如果没有任何与之关联的引用，即他们的引用计数都为0，则说明对象不太可能在被用到，这个对象就是可回收对象
  + 
+ 根搜索法
  + 以一系列的 GC roots 对象作为起点搜索
    + 虚拟机栈（栈帧中的本地变量表）中引用的对象；
    + 方法区中的类静态属性引用的对象；
    + 方法区中常量引用的对象；
    + 本地方法栈中JNI（即一般说的Native方法）中引用的对象
  + 如果在 GC roots 和一个对象之间没有可达路径，则称这个对象是不可达的
  + 不可达不代表可回收，不可达对象变为可回收对象至少要经过两次标记过程。

##### 垃圾收集算法

+ 标记清除算法
  + 分为**标记和清除**两个阶段
  + 标记阶段是标记出所有需要回收的对象
  + 清除阶段回收被标记的对象所占的空间
  + 该算法最大的问题是 **内存碎片化严重**，大对象可能找不到可利用空间

+ 复制算法
  + 将内存划分为等大小的两块，每次只使用一块，当一块存满后，将尚存活的对象复制到另一块中，清空内存。
  + **问题是内存效率不高**
+ 标记整理算法
  + 标记阶段是标记需要回收的对象
  + 标记后，将存活对象移到内存的一端，然后清除端边界外的对象

+ 分代收集算法
  + 见上

---

#### 4.4 Java 四种引用类型

+ 强引用
  + 最常见的引用，**把一个对象赋给一个引用变量，这个引用变量就是一个强引用**
  + 当一个对象被强引用变量引用时，处于可达状态，不可能被垃圾回收机制回收。
+ 软引用
  + **软引用需要用 softReference 类来实现**
  + 对象与只有软引用的对象来说，当系统内存足够时不会被回收，当系统内存空间不足是会被回收。
+ 弱引用
  + 弱引用用 weakReference 类来实现
  + 比软引用的生存期更短，只要垃圾回收机制一运行，就会被回收
+ 虚引用
  + 虚引用用 phantomReference类来实现
  + 不能单独使用，必须和引用队列联合使用
  + 虚引用主要作用是**跟踪对象被垃圾回收的状态**

---

#### 4.5 GC 垃圾收集器

> Java 堆内存被划分为新生代和老年代两部分，新生代的主要算法是复制和标记-清除垃圾回收算法，老年代主要是用标记-整理算法，因此针对老年代和新生代提供了很多不同的垃圾收集器

![image-20200217110145983](D:\Desktop\面试\img\image-20200217110145983.png)

+ Serial 垃圾收集器
  + 最基本的垃圾收集器，使用**复制算法**，**单线程**收集器
  + **工作是必须暂停其他所有工作线程** -- 导致上下文切换
  + Java虚拟机运行在 Client 模式下默认的新生代垃圾收集器

+ ParNew 垃圾收集器

  + 是 Serial 收集器的多线程版本
  + 工作是必须暂停其他所有工作线程
  + 默认开启和 CPU 相同数量的线程数，可通过 ParallelGCThreads参数来设置
  + JVM 运行在 server 模式下默认的新生代垃圾收集器

+ Parallel Scavenge 收集器

  + 使用**复制算法**，多线程，新生代垃圾收集器
  + 重点关注的是程序达到一个可控制的吞吐量
  + 主要适用于后台运算而不需要太多交互的任务
  + 自适应调节策略是 Parallel Scavenge 收集器与parnew收集器的一个重要区别

+ serial old 收集器

  + serial 收集器的老年代版本，单线程，使用**标记整理算法**
  + 是 Client 模式下虚拟机的默认老年代垃圾收集器

  ![image-20200217112532886](D:\Desktop\面试\img\image-20200217112532886.png)

  ![image-20200217112620480](D:\Desktop\面试\img\image-20200217112620480.png)

+ parallel old 收集器

  + parallel scavenge 的老年代版本，多线程，**标记-整理算法**，1.6版本之后才提供
  + parallel old 与 parallel scavenge收集器配合，提高整体吞吐量

  ![image-20200217112642923](D:\Desktop\面试\img\image-20200217112642923.png)

+ CMS 收集器

  + 老年代垃圾收集器，多线程，**标记-清除算法**
  + 主要目标是**获取最短垃圾回收停顿时间**，可以为交互比较多的程序提高用户体验
  + 工作机制
    + 初始标记：知识标记一下 GC roots 能直接关联的对象，速度很快，仍然需要停止所有工作线程
    + 并发标记：进行 GC roots 跟踪过程，和用户线程一起工作
    + 重新标记：为了修正并发标记期间，因用户程序继续运行而导致的标记产生变动的那一部分对象的标记记录，仍然要暂停所有工作流程
    + 并发清除：清除掉GC roots 不可达对象，和用户线程一起工作。

  ![image-20200217112702324](D:\Desktop\面试\img\image-20200217112702324.png)

+ G1 收集器

  + 基于**标记-整理算法**，不产生内存锁片
  + 可以非常精确的控制停顿时间

  + **G1 收集器把堆分为大小固定的几个独立区域**，直接对新生代和老年代一起回收，并且跟踪这些区域的来及收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。

---

#### 4.6 类加载机制

类加载过程包含了加载、验证、准备、解析和初始化 5 个阶段

+ 加载

  + 通过类的完全限定名获取定义该类的**二进制字节流**
  + 将该字节流表示的静态存储结构转化为方法区的**运行时存储结构**
  + 在内存中生成一个代表该类的 **Class 对象**，作为方法区中该类各种数据的访问入口

+ 验证

  + 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

+ 准备

  + 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存

  ```java
  public static int value = 123; // 初始值为0，而不是123
  
  public static final int value = 123; // 类变量是常量，初始化是指定值
  ```

+ 解析

  + 将常量池的符号引用替换为直接引用的过程

+ 初始化

  + 真正开始执行类中定义的 Java 程序代码。
  + 虚拟机执行类构造器方法，根据程序的计划去初始化类变量和其他资源

---

#### 4.7 Java 对象的创建和访问

**对象的创建**

+ **检测类是否被加载**，如果没有被加载，需要先加载类之后继续执行
+ **为对象分配内存**
+ **为分配的内存空间初始化零值**
+ **对对象进行其他设置**，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息
+ **执行init 方法**

**对象的访问**

+ 使用**句柄**访问对象
  + Java 堆中会划分出一块内存作为句柄池，栈帧中存储的是对象的句柄地址，句柄中包含了对象时候数据和类型数据各自的具体地址信息。
+ 使用直接指针访问对象
  + 栈帧中存储的就是对象的地址

---

#### 4.8 String 类和常量池

JVM 为提高性能减少内存开销，为字符串开辟一个字符串常量池，创建字符串时，首先检查字符串常量池是否存在该字符串，存在，返回引用实例，不存在，实例化该字符串并放入池中。



### 5.设计模式

#### 5.1 单例模式

+ 核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点
+ 实现方式
  + 饿汉式：线程安全，调用效率高，但是不能延时加载
  + 懒汉式：线程安全，调用效率不高，可以延时加载
  + 双重校验锁懒汉式：由于 JVM 内存模型的原因，偶尔会出现问题，不建议使用
  + 饿汉式改进：静态内部类（线程安全，调用效率高，可以延时加载）

```java
// 饿汉式
public class Singleton{
    // 1.私有化构造器
    private Singleton(){}
    // 2. 类初始化时，立即加载该对象
    private static Singleton instance = new Singleton();
    // 3.提供获取该对象的方法，没有synchronized，效率高
    public static Singleton getInstance() {
        return instance;
    } 
}
```

```java
// 懒汉式
public class Singleton{
    // 1. 私有化构造器
    private Singleton(){}
    // 2.类初始化时，不立即加载该对象
    private static Singleton instance;
    // 3.提供获取该对象的方法，有synchronized，效率低
    public static synchronized Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}
```

```java
// DCL懒汉式 - 双重检验锁 -- 提高懒汉式的效率
public class Singleton {
    private Singleton(){}
    // volatile 可以使得一个线程的操作对另外一个线程是立即生效的
    private volatile static Singleton instance;
    public static Singleton getInstance() {
        if (instance == null){
            synchronized(Singleton.class) {
                // 由于JVM排序优化，可能先进行地址分配
                if (instance == null)
                     instance = new Singleton();
            }
        }
        return instance;
    }
}
```

```java
public class Singleton {
    private Singleton(){}
    private static class InnerClass {
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return InnerClass.instance;
    }
}
```



#### 5.2 工厂模式

作用：实现了创建者和调用者的分离

详细分类：

+ 简单工厂模式
+ 工厂方法模式
+ 抽象工厂模式

OOP七大原则：

+ **开闭原则**：一个软件的实体应当对扩展开放，对修改关闭
+ **依赖倒置原则**：要针对**接口编程**，不要针对实现编程
+ **迪米特法则**：只与你直接的朋友通信，而避免和陌生人通信

核心本质：

+ 实例化对象不使用 new，用工厂方法代替
+ 将调用者和实现类解耦

##### 5.2.1 简单工厂模式

> 用来生产同一等级结构中的任意产品（对增加新的产品，需要扩展已有代码）

![image-20200220130120212](D:\Desktop\面试\img\image-20200220130120212.png)

##### 5.2.2 工厂方法模式

> 用来生产同一等级结构中的固定产品(支持增加任意产品)

![image-20200220130612911](D:\Desktop\面试\img\image-20200220130612911.png)



#### 5.3 抽象工厂模式

定义：抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类。

适用场景：

+ 客户端（应用层）不依赖于产品实例如何被创建、实现等细节
+ 强调一些列相关的产品对象一起使用创建对象需要大量的重复代码
+ 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现



产品等级相对固定的产品族，可以考虑使用抽象工厂模式

+ 产品等级：不同类型的产品 - 手机、路由器

+ 产品族：生成不同产品的一个公司 - 小米 、华为

**产品簇**

**|小米手机  小米路由器**

**|华为手机  华为路由器**

  **一一一一一一一一一一产品等级**

  ![image-20200222154506351](D:\Desktop\面试\img\image-20200222154506351.png)



#### 5.4 代理模式

##### 1. 静态代理

**角色分析**

+ 抽象角色：一般会使用接口或抽象的类来解决

+ 真实角色：被代理的角色

+ 代理角色：代理真实角色，代理真实角色后，我们会做一些附属操作
+ 客户：访问代理对象的人



**代码步骤**

+ 接口

```java
//抽象角色：租房
public interface Rent {
    public void rent();
}
```

+ 真实角色

```java
// 真实角色：房东
public class Host implements Rent{
    @Override
    public void rent() {
        System.out.println("我是房东，我要出租房子!!!");
    }
}
```

+ 代理角色

```java
// 代理角色：
public class Proxy {
    // 利用组合的方式
    private Host host;
    public Proxy(){}
    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        visit();
        host.rent();
        contract();
    }

    public void visit() {
        System.out.println("代理带你看房子");
    }

    public void contract() {
        System.out.println("代理和你签合同");
    }
}
```

+ 客户端访问代理角色

```java
// 客户
public class Client {
    public static void main(String[] args) {
        // 直接通过房东来租到房子
        // Host host = new Host();
        // host.rent();

        // 通过中介来租到房子
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
```



**代理模式的好处**

+ 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
+ 公共业务就交给代理角色，**实现了业务的分工**
+ **公共业务发生扩展的时候**，方便集中管理

**缺点：**

+ 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低



##### 2. 动态代理

角色分析

+ 角色和动态代理一样
+ 动态代理的代理类是动态生成的，不是我们直接写好的
+ 动态代理分为两大类：基于接口和基于类
  + 基于接口-- JDK静态代理 【实现】
  + 基于类：cglib
  + java 字节码实现：javassist



需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序

**InvocationHandler**







## `MySQL`

### 1.事务

---

#### 1.1什么是事务？

事务是逻辑上的一组操作，要么都执行，要么都不执行

---

#### 1.2 事务的特性(ACID)

+ 原子性：事务执行的最小单位，用来保证事务要么完成，要么完全不起作用
+ 一致性：保证事务之前前后数据保持一致性
+ 隔离性：并发访问数据库时，一个用户的事务不被其他事务干扰，是独立的
+ 持久性：事务提交之后，对数据库内数据的改变时持久的

---

#### 1.3 并发事务带来的问题

+ **脏读**：一个事务读取了另外一个事务还未提交的数据
+ **不可重复读**：一个事务多次读取一个数据，结果不一样的
+ **幻读**：一个事务多次读取几行数据，结果不一样
+ **丢失修改**：一个事务读取数据后，修改，还没提交，另一个事务也对这个数据进行修改，这样导致第一个事务修改的数据丢失。

**不可重复读和幻读的区别**：

+ 不可重复读重点是修改，也即一个事务读取一个数据后，再次读取这个数据时，这个数据被修改了
+ 幻读重点在于新增或删除，也即一个事务读取了几行数据，比如是5行，再次读取时，满足条件的数据变多或变少了

---

#### 1.4 事务的隔离级别

+ **读取未提交**：最低隔离级别，允许读取尚未提交的数据，**可能导致脏读，不可重复读，幻读**
+ **读取已提交**：允许读取并发事务已经提交的数据，**可以阻止脏读，但不可重复读和幻读不可阻止**
+ **可重复读**：对同一个字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**
+ **可串行化**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

---

#### 1.5 事务隔离怎么实现

基于锁来实现

---

#### 1.6 数据库有哪些锁

+ 行级锁
  + 最细力度的锁，只针对当前操作的行加锁
  + 开销大，会出现死锁
  + 发生锁冲突的概率最低
+ 表级锁
  + 最大力度的锁，对当前操作的整张表进行加锁。
  + 开销小，不会出现死锁
  + 发生冲突的概率最高
+ 页级锁
  + 介于行级锁和标记锁之间
  + 开销和冲突适中，会出现死锁

---

#### 1.7 什么是乐观锁，什么是悲观锁，如何实现？

+ 悲观锁
  + 对数据被意外修改保持保守态度
  + 依赖数据库的原生支持的锁机制实现，防止其他事务对目标事务进行破坏
  + 在执行事务前或中申请加锁，执行完后再释放
  + 对长事务，可能严重影响到并发处理能力
+ 乐观锁
  + 每次去读取数据都认为别人没有修改过，不会上锁
  + 但是提交更新的时候会判断一下此期间有没有去更新这个数据
  + 乐观锁适合读多写少的场景

---



### 2. 索引

> 索引是为了提高数据库查询的一种数据结构，以协助快速查询、更新数据库表中数据

---

#### 2.1 索引有哪几种类型？

+ **主键索引**：数据列不允许重复，不允许为null，一个表只能有一个主键

+ **唯一索引**：数据类不允许重复，允许为null，一个表允许多个列创建唯一索引

  ```sql
  ALTER TABLE table_name ADD UNIQUE(column);
  ALTER TABLE table_name ADD UNIQUE(column1, column2,...);
  ```

+ **普通索引**：基本的索引类型，没有唯一性的限制，允许为null

  ```sql
  ALTER TABLE table_name ADD INDEX index_name (column);
  ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);
  ```

+ **全文索引**：目前搜索引擎使用的一种关键技术

---

#### 2.2 什么是最左前缀

+ 最左优先，在创建多列索引时，根据业务需求，where子句中使用最频繁的一列放在最左边。

---

#### 2.3 索引的两种数据结构

+ 哈希索引
  + 底层数据结构就是哈希表，对于单条记录查询，查询性能最快
+ BTree索引
  + 使用B树中的B+Tree
  + 但是MyISAM和InnoDB在实现上有所不同

---

#### 2.4 MyISAM 和 InnoDB 实现 BTree索引方式的区别

+ MyISAM
  + B+Tree的叶节点的data域存放的是数据记录的地址
  + 索引时，首先按照索引方法搜索索引，如果指定的key值存在，取出其data域的值
  + 然后根据data域的值去读取响应的数据
  + 称为“非聚簇索引”
+ InnoDB
  + MyISAM中索引文件和数据文件时分离的，索引文件金宝村数据记录的地址，InnoDB中，表数据文件本身就是一个 B+Tree 组织的一个索引结构，也即**叶节点的data域保存了完整的数据记录**，称为聚集索引。因此要求表必须有主键，若没有，系统会自动选择，若没有这样的列，会生成一个隐含字段作为主键
  + InnoDB的所有**辅助索引都引用主键作为data域。**
  + 因此，我们推荐不要使用过长的字段作为主键，导致辅助索引变得过大
  + 同时，推荐使用单调的字段作为主键，会降低b+tree的分裂次数

---

#### 2.5 使用索引的注意事项

+ 避免在**where子句**中对字段施加函数，否则会导致**索引无法命中**
+ 在使用innodb是，使用与业务无关的自增主键作为主键，即**使用逻辑主键**，不要使用业务主键
+ 将打算加索引的列是指为**not nul**l，否则会导致引擎放弃使用索引而进行权标扫描
+ **删除**长期不使用的索引

---



### 3. 如何优化sql

> 当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，因此我们需要进行优化

+ **限定数据的范围**：务必静止不带任何限制数据范围的查询语句。
+ **读/写分离**：主库负责写，从库负责读
+ **垂直分区**
  + **根据数据库里面数据表的相关性进行拆分**
  + 比如用户表中既有用户的登录信息又有用户的基本信息，我们可以拆分为两个独立的表，甚至放到单独的库做分库。
  + **简单来说垂直拆分就是把一张列比较多的表拆分为两张表**
  + 优点：可以使得行数据边小，查询是减少读取的block数，减少i/o操作
  + 缺点：主键会出现冗余，需要管理冗余列，并会引起join操作，会使得事务变得复杂
+ **水平分区**
  + **保持数据表结构不变，通过某种策略存储数据分片**
  + **这样每一片数据分散到不同的表或库中，达到了分布式的目的**
  + **可以支持非常大的数据量**
  + 水平拆分最好分库
  + 但是数据分片会带来逻辑、部署和运维等各种问题，不到万不得已不要分片。
  + 数据库分片的两种方案
    + 客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或分装JDBC层来实现
    + 中间件代理：在应用层和数据中间加一个代理成，分片逻辑统一维护在中间件服务中。

---



## `计算机网络`

### 1. 网络 7 层架构

+ **物理层**：定义**物理设备标准**，主要作用是传输比特流，这一层的数据叫做**比特**
+ **数据链路层**：主要将从物理层接收的数据进行**MAC 地址的封装与解封装**，这一层的数据叫**帧**，工作的设备是**交换机**。
+ **网络层**：主要将从下层接收的数据进行 **IP 地址的封装和解封装**，这一层的数据叫**数据包**，这一层工作的设备是**路由器**。
+ **传输层**：定义了一些传输数据的**协议和端口号**，如tcp，udp等，这层数据叫**段**
+ **会话层**：通过传输层**建立数据传输的通道**。
+ **表示层**：主要是进行对接收的数据进行**解释、加密与解密、压缩与解压缩**
+ **应用层**：主要是一些终端的**应用**。

---

### 2. TCP/IP 原理

+ **网络访问层**：主机必须使用某种协议与网路相连
+ **网络层**：功能是使主机把分组发往任何网络，并使分组独立地传向目标。
+ **传输层**：使源端和终端机上的对等实体可以会话
  + 定义了两个端对端的协议：TCP UDP
+ **应用层**：包含了所有的高层协议

---

### 3. TCP 和 UDP 协议的区别

+ TCP
  + 传输控制协议
  + 面向连接的协议，在传送数据前必须先建立连接，数据传送结束之后要释放连接。
  + 是可靠的，具有流量控制、多路复用等功能
+ UDP
  + 用户数据报协议
  + 面向无连接的不可靠的传输协议，在某些情况下是一种最有效的工作方式，QQ语言、视频、直播等等

---

### 4. TCP 三次握手和四次挥手

**三次握手**

+ 客户端-发送带有 SYN 标志的数据包 - 一次握手 - 服务端
+ 服务端 - 发送带有 SYN/ACK 标志的数据包 - 二次握手 - 客户端
+ 客户端 - 发送带有 ACK 标志的数据包 - 三次握手 - 服务端

**为什么要三次握手？**

+ 目的是为了建立可靠的通信通道，双方确认自己与对方的发送与接收是正常的
+ 第一次握手：Client 什么都不能确认，server端确认对方发送正常
+ 第二次握手：client 确认：自己发送、接收正常，对方发送、接收正常，server确认自己接收正常，对方发送正常
+ 第三次握手：client 确认：自己发送、接收正常，对方发送、接收正常，server确认：自己发送、接收正常，对方发送、接收正常

**四次挥手**

+ 客户端 - 发送一个 FIN ，用来关闭客户端到服务器的数据传送
+ 服务器 - 收到这个 FIN，发送一个 ACK，确认序号为收到的序号加1。和SYN一样，一个 FIN 将占用一个序号
+ 服务器 - 关闭与客户端的链接， 发送一个 FIN 给客户端
+ 客户端 - 发回 ACK 报文确认，并将确认序号设置为收到序号加 1

---

### 5. 在浏览器中输入 url 地址 -> 显示主页的过程

+ 浏览器查找域名的 IP 地址（DNS解析）
+ 浏览器向 web 服务器发送一个 HTTP 请求（TCP连接，发送HTTP请求）
+ 服务器处理请求
+ 服务器发回一个HTTP 响应
+ 浏览器开始显示 HTML

---

### 6. 各种协议与HTTP协议之间的关系

> 结合网页访问的例子

我们在浏览器输入一个网址，是我们想要访问的界面，这时候，客户端会使用dns域名解析协议来请求IP地址，http协议的职责是生产针对目标web服务器的http请求报文，tcp协议是为了保证客户端与服务端之间的可靠数据连接，会将http请求报文分割成报文段，IP协议负责在网络层对这些包进行传输和中转。当从对方接受到报文段时，重组到达的数据段，http协议对web服务器请求的内容进行处理，至此，请求数据到达服务器端，请求的处理结果，也利用 tcp/ip的通讯协议向用户进行回转





## `Linux`

### Linux 文件系统

在 Linux 操作系统中，所有的资源都被看做是一个文件，**也即一切都是文件**。

### Linux 文件类型和目录结构

**文件类型**

+ **普通文件**
+ **目录文件**：用于表示和管理系统中的文件，目录文件包含一些文件名和子目录名
+ **链接文件**：用于不同目录下文件的共享
+ **设备文件**：用来访问硬件设备
+ **命名管道**：是一种特殊类型的文件，Linux系统下，进程之间通信可以通过该文件完成。

**目录结构**

> Linux 文件系统的结构层次鲜明，就像一颗倒立的树，最顶层是其根目录

+ /
  + **/bin**：存放二进制可执行文件，常用命令一般都在这里
  + /sbin：存放二进制可执行文件，只有root才能访问，这里存放的是只有系统管理员才能使用的系统级别的管理命令和程序。
  + **/etc**：存放系统管理和配置文件
  + **/home**：存放所有用户文件的根目录，是用户主目录的基点
  + **/root**：超级用户（系统管理员）的主目录
  + **/usr**：用于存放系统应用程序
  + **/opt**：额外安装的可选用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里
  + /proc：虚拟文件系统目录，是系统内存的映射
  + /dev：用于存放设备文件
  + /mnt：系统管理员安装临时文件的安装点，系统提供这个目录是让用户临时挂载其他的文件系统
  + /lib：存放着和系统运行相关的库文件
  + /tmp：用于存放各种临时文件，是公用的临时文件存储点
  + /var：用于存放运行时需要改变数据的文件们也是某些大文件的溢出区



### 一些常用的 Linux 命令

> 目录切换命令

+ cd 目录名
+ cd ../
+ cd /
+ cd ~：切换到用户主目录
+ cd -：切换到上一个所在目录

> 目录的操作命令（增删改查）

+ mkdir 目录名称：增加目录
+ ls 或者 ll ：查看目录信息
+ find 目录 参数：寻找目录
+ mv 目录名称 新目录名称 ：修改目录的名称
+ mv 目录名称 新目录地址：剪切
+ cp -r 目录名称 目录拷贝的目标地址：拷贝目录
+ rm -rf 目录：删除目录

> 文件的操作命令（增删改查）

+ touch 文件名称：文件的创建
+ cat/more/less/tail 文件名称：文件的查看
  + cat：只能显示文件的最后一屏内容
  + more：可以显示百分比，回车可以向下一行，空格可以线下一页，q可以退出查看
  + less
  + tail -10：查看文件的最后10行
+ vim 文件：修改文件内容
  + vim有三种模式：命令模式--编辑模式--末行模式
+ rm -rf 文件：删除文件

> 软件包

+ 下载软件包
  + rpm -ivh 包全名
  + yum -y install 包全名

>  打包和解压文件

+ 打包
  + `tar -zcf xxx.tar.gz xxx`

+ 解压
  + `tar -zxf xxx xxx.tar.gz`



### Shell 工具

#### cut

> cut 的工作就是剪，具体的说就是在文件中负责剪切数据用的。
>
> cut命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出

cut [选项参数] filename

#### sed

> sed 是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为模式空间，接着用sed 命令处理缓冲区中的内容，处理完成后，吧缓冲区的内容送完屏幕。接着处理下一行，知道文件末行。
>
> **文件内容并没有改变**，除非你使用重定向存储输出

sed [选项参数] ‘command’  filename



#### awk

`awk [选项参数] ‘pattern1 {action1}  pattern2 {action2}...’  filename`

```linux
// 打印出以root开头的第七列
awk -F : '/^root/ {print $7}' passwd

// 搜索 passwd 文件以root关键字开头的所有行，并输出改行的第1列和第7列，其中以“，”号分割
awk -F : '/^root/ {print $1","$7}' passwd

// 只显示 /etc/passwd 的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell 在最后一行添加 “chenjing， /bin/chenjing”
awk -F: 'BEGIN{print "user,shell"} {print $1","$7} END{print "chenjing,/bin/chenjing"}' passwd 

//将passwd文件中的用户id增加数值1并输出
awk -F: -v i=1 '{print $3+i}' passwd

// 统计 passwd 文件名，每行的行号，每行的列数
awk -F: '{print FILENAME"-" NR"-" NF}' passwd

// 显示ip地址
ifconfig ens33 | grep -w inet | awk '{print $2}'

//显示sed.txt 中的空行的行号
awk '/^$/{print $1 NR}' sed.txt
```



#### sort

> sort命令是在Linux里非常有用的，它将文件进行排序，并将排序结果标准输出

`sort(选项)(参数)`

+ -n：升序排序
+ -r：降序排序
+ -t：设置排序时所用的分割符号
+ -k：指定需要排序的列



#### 面试题

> 使用linux 命令查看file 中空行所在的行数

```linux
awk '/^$/{print NR}' file
```

> 有文件 file 内容如下
>
> 张三 40
>
> 李四 50
>
> 王五 60
>
> 使用 Linux 命令计算第二列的和并输出

```linux
awk '{sum+=$2} END{print sum}' 
```

> Shell 脚本里如何检查一个文件是否存在？如果不存在该如何处理？

```linux
#!/bin/bash
if [ -f file,txt ]
then
	echo "文件存在"
else
	echo “文件不存在”
fi
```





## `Redis`

> 启动服务： 
>
> ./redis-server /etc/redis.conf
>
> ./redis-cli -p 6379

### 1. Redis数据类型

#### 1.1 Redis 的五种数据类型

+ String（字符串）
+ Hash（哈希，类似java 中的 map）
+ List（列表）
+ Set（集合）
+ Zset（sorted set：有序集合）

#### 1.2 Redis 键（key）

+ keys *：返回所有的key
+ exists key的名字：判断是否存在某个key
  + 存在为1
  + 不存在为0
+ move key db ：当前库没有，被移除到指定库中
+ expire key 秒钟：为给定的key设置过期时间
+ ttl key：查看还有多少秒过期，-1表示永不过期，-2表示已过期
+ type key：查看你的key是什么类型的

#### 1.3 String 字符串

> 单值单value

+ get / set / del / append / strlen
+ Incr / decr / incrby / decrby 一定要是数字才能进行加减
+ getrange / setrange
+ setex (键值 秒数 值) / setnx(键值 值) -- 不存在才会成功

+ mset / mget / msetnx
+ getset (先get再set)

#### 1.4 List 列表

> 单值多value

> 字符串链表，left 和 right 都可以插入添加
>
> 如果键不存在，创建新的链表
>
> 如果键已存在，新增内容
>
> 如果值全部移除，对应的键也就消失
>
> 对于头和尾巴的操作效率高，对中间元素的操作效率低

+ lpush / rpush/ lrange
+ lpop / rpop

+ lindex：按照索引来获取元素下标（从上到下）
+ llen
+ lrem key n value：删除n个value值
+ ltrim key start end：截取指定的范围的值后再复制给key（从上到下）
+ rpoplpush 原链表 目标列表
+ lset key index value：将某个位置的值设置为指定值
+ linsert key before/after value1 value2：在某个值之前/之后插入一些值

#### 1.5 集合 set

> 单值多value

+ sadd/smembers/sismember：添加成员到set中/显示成员/判断是否为成员

+ scard：元素个数

+ srem key value 删除集合中的元素

+ srandmember key 某个整数：随机出几个数

+ spop key：随机出栈

+ smove key1 key2 key1中的某个值：将key1中的某个值赋给key2

+ 数学集合类

  + 差集 sdiff
  + 交集 sinter
  + 并集 sunion

  

#### 1.6 hash 哈希表

> KV模式不变，但是V是一个键值对

+ **hset/hget/hmset/hmget/hgetall/hdel**
+ hlen
+ hexists key
+ **hkeys/hvals**
+ hincrby/hincrbyfloat
+ hsetnx







