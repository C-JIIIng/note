## Zookeeper

### 1. 什么是zookeeper

zookeeper是一个分布式协调服务，是集群的管理者，监视各节点情况并给出反馈

---

### 2. zookeeper 数据模型

+ 层次化目录结构（树形结构）
+ 每个节点在zookeeper中叫做znode，并且有一个唯一的路径标识
+ znode可以包含数据和子节点，数据量很小
+ znode中的数据可以有多个版本

---

### 3. zookeeper的节点类型

+ 持久节点：除非删除，否则一直存在
+ 临时节点：客户端会话结束，节点消失
+ 持久顺序节点：基本特性和持久节点差不多，但是节点名后会追加顺序编号
+ 临时顺序节点：基本特性和临时节点差不多，但是节点名后会追加顺序编号

---

### 4. zookeeper角色

+ leader：负责进行投票的发起和决议，更新系统状态
  + 包括一个历史事务集合
+ follower：用于接收客户端的请求并向客户端返回结果，在选举过程中参与投票
+ observer：接收客户端连接，将请求发给leader，但是不参与投票，其目的是为了**扩展系统**（事务性的操作都是由leader决定的，所以在读多的情况下，进行横向扩展是比较有用的），提高读取速度
+ client：请求发起方

---

### 5. zk的读写机制

+ zk是由多个server组成的集群
+ 一个leader和多个follower
+ 每个server保存一份数据副本
+ 全局数据一致
+ 分布式读写
+ 更新请求转发，由leader实施

---

### 6. zk的特点

+ **更新请求顺序进行**，来自同一个client的更新请求按其发送顺序依次执行
+ 数据**更新原子性**，一次数据更新要么成功，要么失败
+ 全局**唯一数据视图**，client不论连接到哪个server，数据视图都是一致的。
+ **实时性，在一定时间范围内**（paxos算法），client能读到最新数据

---

### 7. 两阶段提交 2pc

+ 阶段一：投票阶段
  + 协调者向所有参与者发送是否能提交操作的请求，等待响应
  + 参与者节点执行事务操作，并将undo和redo的信息写入日志
  + 参与者响应请求，如果操作成功，回复yes，操作失败，回复no

+ 阶段二：提交阶段
  + 若参与者响应都是 yes
    + 协调者向所有参与者节点发出“commit”请求
    + 参与者节点正式完成操作，释放资源
    + 参与者节点向协调者发送完成消息
    + 协调者接收信息，完成事务
  + 若有部分参与者节点回复 no
    + 协调者向所有参与者节点发出“rollback”请求
    + 参与者节点根据undo日志做回滚操作，释放资源
    + 参与者节点向协调者发送完成消息
    + 协调者接收信息，完成事务

+ 缺点：
  + 同步阻塞
    + 投票阶段：参1 --> 协（快） 结束了， 参2 --> 协（慢），参1被阻塞
  + 单点故障

  + 数据不一致（脑裂）
    + 协 -->  commit --> 参，发现网络故障 -- 导致一部分commit 和 一部分没有commit

---

### 8. paxos算法

一种基于消息传递的分布式一致性算法，具有高容错性

paxos算法将系统中的角色分为

+ proposer
  + 提出提案，提案信息包括提案编号和提议值
+ acceptor
  + 参与决策，回应proposer的提案，收到提案后可以接收提案，若提案被大多数的acceptor接收，则此提案被批准
+ learner
  + 不参与决策

paxos算法包括两个阶段

+ 准备阶段
  + Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。
+ 提交阶段
  + Acceptors收到Prepare请求后，做出“两个承诺，一个应答”
  + 两个承诺：
    + 不再接受Proposal ID小于等于（注意：这里是<= ）当前请求的Prepare请求。
    + 不再接受Proposal ID小于（注意：这里是< ）当前请求的Propose请求。
  + 一个应答：
    + 不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。

为什么要设置为半数提交？



---

### 9. ZAB协议

> zk底层的协议

**zxid** ：每个事务都有一个编号zxid，包括两个部分

+ 高32为epoch是指选举周期，经过一次选举就累加1
+ 低32位是递增计数器：随着事务的到来递增

**ZAB协议**

zk的核心是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做 ZAB 协议。ZAB 协议有两种模式：

+ 恢复模式
  + 当服务器启动或leader宕机后，ZAB就会进入恢复模式，当**leader被选举**出来，且大多数server都完成了和leader的**同步**，恢复模式就结束，进入广播模式。
+ 广播模式



**恢复服务**

+ leader选举
  + 只需要保证选举出的leader服务器拥有集群中所有机器最高编码(即ZXID最大)的事务
+ 数据同步
  + leader会为每一个follower服务器准备一个队列，将哪些没有被各个follower同步的事务以proposal的形式逐个发送给follower服务器，并在proposal后面紧跟着发送一个commit请求，以表示该事务已经被提交，当follower将数据同步完成之后，leader会将该follower加入到真正可用的follower队列中。



**选举：fastleaderrelection 算法**

+ 每个节点初始化自己的选票（myid，zxid）
+ 发送初始化选票
+ 接收外部选票
+ 判断，如果外部的zxid 大于 内部，则选择外部，如果zxid相等，选myid最大的服务器
+ 将变更结果重新广播
+ 每个节点将会接收到所有外部的投票
+ 有半数以上的服务器接收自己，则该服务器变为新的leader



### 10.zookeeper应用

+ 统一命名符
+ 集群的管理
+ master选举
+ 分布式锁



### 11. zk的watcher监听机制

zk允许客户端向服务端的某个znode注册一个watcher监听，当服务端的一些指定事件触发了这个watcher，服务端会向指定客户端发送一个时间通知，来实现分布式的通知功能，然后客户端根据watcher通知状态和时间类型做出业务上的改变。

监听事件

+ 创建新的节点：用exists方法设置监听
+ 删除节点：调用exist，getData，getChildren设置监听
+ 节点变化：getData设置监听
+ 子节点变化：调用getChildren设置监听