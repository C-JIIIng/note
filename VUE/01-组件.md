

# 组件

## 定义Vue组件

什么是组件：组件的出现 是为了拆分Vue实例的代码，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可

组件化和模块化的不同：

+ 模块化：是从代码逻辑的角度去划分的；方便代码分层开发 保证每个功能模块的职能单一
+ 组件化：是从UI界面的角度进行划分的，前端的组件化，方便UI组件的组件的重用

### 定义全局组件

#### 方式一

``` js
<div id="app">
	<!--如果好使用组件 直接 把组件的名称 以HTML标签的形式 引入到页面中-->
    <my-com1></my-com1>
</div>

<script>
    //1.1使用 Vue.extend 来创建全局的Vue组件
    // var com1 = Vue.extend({
    // template:'<h3>这是使用 Vue.extend 创建出来的组件</h3>'//通过 template 属性 指定了组件	要显示的HTML结构
    // })
    // 1.2 使用Vue.component('组件的名称',创建出来的组件模板对象)
    // 如果使用Vue.component 定义去全局组件时 组件名称使用了 驼峰命名 则再引用组件时 需要把大写的驼峰改为小写的 并且用 - 来连接
    // Vue.component('myCom1',com1)

    // Vue.component 第一个参数：组件的名称 将来在引用组件的时候 就是一个标签形式 来引入
    //第二个参数: Vue.extend 创建的组件 其中 template 就是组件要展示的HTML内容
    Vue.component('myCom1',Vue.extend({
        template:'<h3>这是使用 Vue.extend 创建出来的组件</h3>'//通过 template 属性 指定了组件要显示的HTML结构
    }))
</script>
```

#### 方式二

```js
<div id="app">
<!--   还是使用标签形式，引入自己的组件-->
    <mycom2></mycom2>
</div>
<script>
    //注意：无论是哪种方式创建出来的组件 组件的template属性指向的模板内容 必须有且只能有唯一第一个根元素
    Vue.component('mycom2',{
        template:'<div><h3>这是直接使用Vue.component 创建出来的组件</h3><span>123</span></div>'
    })
</script>
```

#### 方式三

```js
<div id="app">
    <mycom3></mycom3>
</div>
<!-- 在被控制的 app 外面 使用template 元素 定义组件的HTML模板结构-->
<template id="tmp1">
    <div>
        <h1>这是通过template元素，在外部定义的组件结构，这个方式，有代码的智能提示和高亮</h1>
        <h4>好用</h4>
    </div>
</template>
<script>
    Vue.component('mycom3',{
        template:'#tmp1'
    })
```

### 定义私有组件

```js
<div id="app2">
    <login></login>
</div>
<template id="tmp2">
    <div>
        <h1>这是私有的login组件</h1>
    </div>
</template>
<script>
    var vm2 = new Vue({
        el:'#app2',
        components:{//定义实例内部的私有组件
            login:{
                template:'#tmp2'
            }
        }
    })
</script>
```



## Vue组件中的data和methods

```js
<div id="app">
    <counter></counter>
</div>
<template id="tmp1">
    <div>
        <input type="button" value="+1" @click="add">
        <h3>{{ count }}</h3>
    </div>
</template>
<script>
    // 1.组件可以有自己的data数据
    // 2.组件中的data必须是一个函数
    // 3.内部必须要返回一个对象
    // 4.组件中的data数据使用方法和实例汇总data中的使用方法一样        
            
    // 这是一个计数器组件 身上有个按钮 每当点击按钮 让data中的值+1
    Vue.component('counter',{
        template:'#tmp1',
        data:function () {
            return {
                count:0
            }
        },
        methods: {
            add(){
                this.count++;
            }
        }
    })
</script>
```



## 组件切换

### 方式一	

```js
<div id="app">
    <a href="" @click.prevent="flag=true">登录</a>
    <a href="" @click.prevent="flag=flase">注册</a>
	
	//结合 v-if 和 v-else 来实现组件之间的切换
    <login v-if="flag"></login>
    <register v-else="flag"></register>
</div>
<script>
    Vue.component('login',{
        template:'<h3>登录组件</h3>'
    })
    Vue.component('register',{
        template:'<h3>注册组件</h3>'
    })
    var vm = new Vue({
        el:'#app',
        data:{
            flag:true
        },
        methods:{}
    })
</script>
```

### 方式二

```js
<div id="app">

    <a href="" @click.prevent="comName='login'">登录</a>
    <a href="" @click.prevent="comName='register'">注册</a>
    <!--  Vue提供了 component，来展示对应名称的组件  -->
    <!--  component 是一个占位符，:is 属性，可以用来指定要展示的组件的名称  -->
    <component :is="comName"></component>

    <!--  总结：当前学习了几个 Vue 提供的标签了  -->
    <!--  component template transition transitionGroup  -->

</div>
<script>
    // 组件名称是一个字符串
    Vue.component('login',{
        template:'<h3>登录组件</h3>'
    })
    Vue.component('register',{
        template:'<h3>注册组件</h3>'
    })
    var vm = new Vue({
        el:'#app',
        data:{
            comName:'login'// 当前 component 中的 :is 属性绑定的组件的名称
        },
        methods:{}
    })
</script>
```

### 组件切换的动画

```js
<style>
    .v-enter,.v-leave-active{
        opacity: 0;
        transform: translateX(150px);
    }
.v-enter-active,
    .v-leave-active{
        transition: all .3s ease;
    }
</style>

<div id="app">

    <a href="" @click.prevent="comName='login'">登录</a>
    <a href="" @click.prevent="comName='register'">注册</a>

    <!-- 通过mode属性，设置组件切换时候的 模式   -->
    <transition mode="out-in">
        <component :is="comName"></component>
    </transition>

</div>

<script>
    // 组件名称是一个字符串
    Vue.component('login',{
        template:'<h3>登录组件</h3>'
    })
    Vue.component('register',{
        template:'<h3>注册组件</h3>'
    })
    var vm = new Vue({
        el:'#app',
        data:{
            comName:'login'// 当前 component 中的 :is 属性绑定的组件的名称
        },
        methods:{}
    })
</script>
```



## 父组件和子组件

### 父组件向子组件传值

```js
<div id="app">
    <!--  父组件 可以在引用子组件的时候 通过 属性绑定(v-bind)的形式 把需要传递给子组件的数据 传递到子组件内部 供子组件使用  -->
    <com1 :parentmsg="msg"></com1>
</div>
<script>
    var vm = new Vue({
        el:'#app',
        data:{
            msg:'父组件中的数据'
        },
        methods:{},
        components:{
          // 结论：经过演示 发现 子组件中 默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法
            com1:{
                data() {//注意：子组件中的data数据 并不是通过 父组件传递过来的 而是子组件自身私有的
                        // 比如：子组件通过 ajax 请求回来的数据 都可以放在data 身上
                        // data 数据为可读可写的
                    return{
                        title:'123',
                        content:'qqq'
                    }
                },
                template:'<h1 @click="change">这是子组件--{{ parentmsg }}</h1>',
                // 注意：组件中的 所有 props 中的数据 都是 通过父组件传递给子组件的
                // props 中的数据都是只读的
                props:['parentmsg'],//把 父组件传递过来的 parentMsg 属性 先在props中定义
                methods:{
                    // 不推荐 会报错
                    change(){
                        this.parentmsg = '123'
                    }
                }
            }
        }
    })
</script>
```

#### 组件中的data和props的区别

+ data
  + 子组件中的data数据 并不是通过 父组件传递过来的 而是子组件自身私有的
     比如：子组件通过 ajax 请求回来的数据 都可以放在data 身上
  + data 数据为可读可写的
+ props
  + 组件中的 所有 props 中的数据 都是 通过父组件传递给子组件的
  + props 中的数据都是只读的

### 父组件向子组件传递方法

```js
<div id="app">
    <!-- 父组件向子组件传递方法 是有使用事件绑定机制（@） 当我们自定义一个事件属性之后 子组件就能够 通过某些方法 来调用 传递进去的   -->
    <com1 @func="show"></com1>
</div>

<template id="tmp1">
    <div>
        <h1>这是子组件</h1>
        <input type="button" value="这是子组件的按钮 点击这个按钮 会触发父组件的 show 方法" @click="myclick">
    </div>
</template>

<script>

    // 定义了一个字面量类型的组件模板对象
    var com1 = {
        template:'#tmp1', // 通过指定一个id 表示说 要去加载这个指定id的template元素中的内容 当做组件的HTML结构
        data:function () {
            return {
                sonmsg : {name : 'cj', age: 26}
            }
        },
        methods:{
            myclick(){
                // 可使用 $emit() 方法 来调用 父组件 传递过来的方法
                this.$emit('func',this.sonmsg);
            }
        }
    };

    var vm = new Vue({
        el:'#app',
        data:{
            datamsgFromSon:null
        },
        methods:{
            show(data){
                console.log('调用了父组件的 show 方法--'+ data)
                // console.log(data)
                this.datamsgFromSon = data
            }
        },
        components:{
            com1
            // com1 : com1
        }
    })
</script>
```

#### 流程

+ 在父组件中定义一个方法 show
+ 在组件标签中 使用事件绑定机制 来进行使得 父组件的方法 传递进来
+ 在子组件中 使用 $emit() 来调用传递进来的方法
+ $emit(事件名称，参数，参数...)  this.$emit('func',this.sonmsg);
+ 可以使得子组件可以调用父组件的方法 父组件可以使用子组件的数据

### ref

在vm实例中，有一个$refs属性

![ref](D:\workplace\总结\VUE\图片\ref.png)

#### 通过ref获取DOM元素

```js
<div id="app">
    <button @click="getElement" ref="mybtn">获取元素</button>
    <h3 ref="myh3">今天是个好日子</h3>
</div>
var vm = new Vue({
    el:'#app',
    data:{},
    methods:{
        getElement(){
            // console.log(document.getElementsByTagName('h3')[0].innerHTML);
            // ref 是单词 reference
            console.log(this.$refs.myh3.innerHTML)
            console.log(this.$refs.mybtn.innerHTML)
        }
    },
})
```

#### 通过ref获取组件

<b>通过 ref 使得父组件可以使用子组件的数据和方法</b>

```js
<div id="app">
    <button @click="getElement" ref="mybtn">获取元素</button>
    <h3 ref="myh3">今天是个好日子</h3>
    <hr>
    <login ref="mylogin"></login>
</div>
<script>
    var login = {
        template:'<h2>登录组件</h2>',
        data(){
            return{
                msg:'son msg'
            }
        },
        methods: {
            show(){
                console.log('调用了子组件的方法');
            }
        }
    }
    var vm = new Vue({
        el:'#app',
        data:{},
        methods:{
            getElement(){
                //这样父组件 就可以使用子组件的数据和方法啦
                console.log(this.$refs.mylogin.msg); // son msg
                this.$refs.mylogin.show();// 调用了子组件的方法
            }
        },
        components:{
            login
        }
    })
</script>
```





## 番外

### localStorage，sessionStorage和cookie的区别

#### 基本使用方法

##### (1)localStorage/sessionStorage

```js
var name = 'sessionDate';
var num = 120;
sessionStorage.setItem(name,num);// 存储数据
sessionStorage.setItem('value2',119);
let dataAll = sessionStorage.valueOf();// 获取全部数据 返回的是storage对象
console.log(dataAll,'获取的全部数据');
var dataSession = sessionStorage.getItem(name); // 获取指定键名数据
var dataSession2 = sessionStorage.sessionDate;//
console.log(dataSession,dataSession2,'获取指定键名数据');
sessionStorage.removeItem(name); // 删除指定键名数据
console.log(dataAll,'获取的全部数据');
sessionStorage.clear();// 清空缓存数据
console.log(dataAll,'获取的全部数据');
```

##### (2) cookie

```js
//设置cookie的函数
function setCookie(cname,cvalue,exdays){
    var d = new Date();
    d.setTime(d.getTime()+ (exdays*24*60*60*1000));
    var expries = 'expries = '+ d.toUTCString();
    document.cookie = cname + '=' + cvalue + ';' + expries + '; path = /';
}
setCookie('token',110, 2);
			
//获取指定名称的cookie值
function getCookie(cname){
    var name = cname + '=';
    var decodedCookie = decodeURIComponent(document.cookie);
    var ca = decodedCookie.split(';');
    for(var i = 0; i < ca.length; i++){
        var c = ca[i];
        while(c.charAt(0) == ' '){
            c = c.substring(1);
        }
        if(c.indexOf(name) == 0){
            return c.substring(name.length,c.length);
        }
    }
    return '';
}
```

#### 三者区别

##### (1)生命周期

+ cookie：可以设置失效时间，没有设置的话，默认是关闭浏览器之后失效
+ localStorage：除非被手动清除，否则会永久保存
+ sessionStorage：仅在当前网络会话下有效，关闭页面或浏览器之后会失效

##### (2)存放数据大小

+ cookie：4kb左右
+ localStorage/sessionStorage：5MB

##### (3)http请求

+ cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
+ localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

##### (4)易用性

+ cookie：需要程序员自己封装，源生的Cookie接口不友好
+ localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

#### 应用场景

从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比storage更好用的。其他情况下，可以使用storage，就用storage。

storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来跨页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。



















































